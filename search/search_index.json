{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-hydrator Laminas\\Hydrator provides utilities for mapping arrays to objects, and vice versa, including facilities for filtering which data is mapped as well as providing mechanisms for mapping nested structures. File issues at https://github.com/laminas/laminas-hydrator/issues Documentation is at https://docs.laminas.dev/laminas-hydrator/","title":"Home"},{"location":"#laminas-hydrator","text":"Laminas\\Hydrator provides utilities for mapping arrays to objects, and vice versa, including facilities for filtering which data is mapped as well as providing mechanisms for mapping nested structures. File issues at https://github.com/laminas/laminas-hydrator/issues Documentation is at https://docs.laminas.dev/laminas-hydrator/","title":"laminas-hydrator"},{"location":"v2/aggregate/","text":"AggregateHydrator Laminas\\Hydrator\\Aggregate\\AggregateHydrator is an implementation of Laminas\\Hydrator\\HydratorInterface that composes multiple hydrators via event listeners. You typically want to use an aggregate hydrator when you want to hydrate or extract data from complex objects that implement multiple interfaces, and therefore need multiple hydrators to handle that in subsequent steps. Installation requirements The AggregateHydrator depends on the laminas-eventmanager component, so be sure to have it installed before getting started: $ composer require laminas/laminas-eventmanager Basic usage A simple use case may be hydrating a BlogPost object, which contains data for the user that created it, the time it was created, the current publishing status, etc: use Laminas\\Hydrator\\Aggregate\\AggregateHydrator; $hydrator = new AggregateHydrator(); // attach the various hydrators capable of handling simpler interfaces $hydrator-&gt;add(new My\\BlogPostHydrator()); $hydrator-&gt;add(new My\\UserAwareObjectHydrator()); $hydrator-&gt;add(new My\\TimestampedObjectHydrator()); $hydrator-&gt;add(new My\\PublishableObjectHydrator()); // ... // Now retrieve the BlogPost object // ... // you can now extract complex data from a blogpost $data = $hydrator-&gt;extract($blogPost); // or you can fill the object with complex data $blogPost = $hydrator-&gt;hydrate($data, $blogPost); Hydrator priorities AggregateHydrator::add has a second optional argument, $priority . If you have two or more hydrators that conflict with each other for same data keys, you may decide which one to execute first or last by passing a higher or lower integer priority, respectively, to this argument. In order to work with this logic, each of the hydrators that are attached should ignore any unknown object type passed in: namespace My; use Laminas\\Hydrator\\HydratorInterface class BlogPostHydrator implements HydratorInterface { public function hydrate($data, $object) { if (! $object instanceof BlogPost) { return $object; } // ... continue hydration ... } public function extract($object) { if (! $object instanceof BlogPost) { return array(); } // ... continue extraction ... } } Advanced use cases Since the AggregateHydrator is event-driven, you can use the EventManager API to tweak its behaviour. Common use cases include: Removal of hydrated data keys (passwords/confidential information) depending on business rules. Caching of the hydration/extraction process. Transformations on extracted data, for compatibility with third-party APIs. In the following example, a cache listener is introduced to speed up hydration, which can be very useful when the same data is requested multiple times: use Laminas\\Hydrator\\Aggregate\\AggregateHydrator; use Laminas\\Hydrator\\Aggregate\\ExtractEvent; use Laminas\\Cache\\Storage\\Adapter\\Memory; $hydrator = new AggregateHydrator(); // Attach the various hydrators: $hydrator-&gt;add(new My\\BlogPostHydrator()); $hydrator-&gt;add(new My\\UserAwareObjectHydrator()); $hydrator-&gt;add(new My\\TimestampedObjectHydrator()); $hydrator-&gt;add(new My\\PublishableObjectHydrator()); // ... $cache = new Memory(); $cacheReadListener = function (ExtractEvent $event) use ($cache) { $object = $event-&gt;getExtractionObject(); if (! $object instanceof BlogPost) { return; } if ($cache-&gt;hasItem($object-&gt;getId())) { $event-&gt;setExtractedData($cache-&gt;getItem($object-&gt;getId())); $event-&gt;stopPropagation(); } }; $cacheWriteListener = function (ExtractEvent $event) use ($cache) { $object = $event-&gt;getExtractionObject(); if (! $object instanceof BlogPost) { return; } $cache-&gt;setItem($object-&gt;getId(), $event-&gt;getExtractedData()); }; // Attaching a high priority listener executed before extraction logic: $eventManager = $hydrator-&gt;getEventManager(); $eventManager()-&gt;attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000); // Attaching a low priority listener executed after extraction logic: $eventManager()-&gt;attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000); With an aggregate hydrator configured in this way, any $hydrator-&gt;extract($blogPost) operation will be cached.","title":"Aggregates"},{"location":"v2/aggregate/#aggregatehydrator","text":"Laminas\\Hydrator\\Aggregate\\AggregateHydrator is an implementation of Laminas\\Hydrator\\HydratorInterface that composes multiple hydrators via event listeners. You typically want to use an aggregate hydrator when you want to hydrate or extract data from complex objects that implement multiple interfaces, and therefore need multiple hydrators to handle that in subsequent steps.","title":"AggregateHydrator"},{"location":"v2/aggregate/#installation-requirements","text":"The AggregateHydrator depends on the laminas-eventmanager component, so be sure to have it installed before getting started: $ composer require laminas/laminas-eventmanager","title":"Installation requirements"},{"location":"v2/aggregate/#basic-usage","text":"A simple use case may be hydrating a BlogPost object, which contains data for the user that created it, the time it was created, the current publishing status, etc: use Laminas\\Hydrator\\Aggregate\\AggregateHydrator; $hydrator = new AggregateHydrator(); // attach the various hydrators capable of handling simpler interfaces $hydrator-&gt;add(new My\\BlogPostHydrator()); $hydrator-&gt;add(new My\\UserAwareObjectHydrator()); $hydrator-&gt;add(new My\\TimestampedObjectHydrator()); $hydrator-&gt;add(new My\\PublishableObjectHydrator()); // ... // Now retrieve the BlogPost object // ... // you can now extract complex data from a blogpost $data = $hydrator-&gt;extract($blogPost); // or you can fill the object with complex data $blogPost = $hydrator-&gt;hydrate($data, $blogPost);","title":"Basic usage"},{"location":"v2/aggregate/#advanced-use-cases","text":"Since the AggregateHydrator is event-driven, you can use the EventManager API to tweak its behaviour. Common use cases include: Removal of hydrated data keys (passwords/confidential information) depending on business rules. Caching of the hydration/extraction process. Transformations on extracted data, for compatibility with third-party APIs. In the following example, a cache listener is introduced to speed up hydration, which can be very useful when the same data is requested multiple times: use Laminas\\Hydrator\\Aggregate\\AggregateHydrator; use Laminas\\Hydrator\\Aggregate\\ExtractEvent; use Laminas\\Cache\\Storage\\Adapter\\Memory; $hydrator = new AggregateHydrator(); // Attach the various hydrators: $hydrator-&gt;add(new My\\BlogPostHydrator()); $hydrator-&gt;add(new My\\UserAwareObjectHydrator()); $hydrator-&gt;add(new My\\TimestampedObjectHydrator()); $hydrator-&gt;add(new My\\PublishableObjectHydrator()); // ... $cache = new Memory(); $cacheReadListener = function (ExtractEvent $event) use ($cache) { $object = $event-&gt;getExtractionObject(); if (! $object instanceof BlogPost) { return; } if ($cache-&gt;hasItem($object-&gt;getId())) { $event-&gt;setExtractedData($cache-&gt;getItem($object-&gt;getId())); $event-&gt;stopPropagation(); } }; $cacheWriteListener = function (ExtractEvent $event) use ($cache) { $object = $event-&gt;getExtractionObject(); if (! $object instanceof BlogPost) { return; } $cache-&gt;setItem($object-&gt;getId(), $event-&gt;getExtractedData()); }; // Attaching a high priority listener executed before extraction logic: $eventManager = $hydrator-&gt;getEventManager(); $eventManager()-&gt;attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000); // Attaching a low priority listener executed after extraction logic: $eventManager()-&gt;attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000); With an aggregate hydrator configured in this way, any $hydrator-&gt;extract($blogPost) operation will be cached.","title":"Advanced use cases"},{"location":"v2/filter/","text":"Laminas\\Hydrator\\Filter Hydrator filters allow you to manipulate the behavior of the extract() operation. This is especially useful, if you want to omit some internals (e.g. getServiceManager() ) from the array representation. It comes with a helpful Composite implementation, and several filters for common use cases. The filters are composed in the AbstractHydrator , so you can start using them immediately in any custom extensions you write that extend that class. namespace Laminas\\Hydrator\\Filter; interface FilterInterface { /** * Should return true, if the given filter * does not match * * @param string $property The name of the property * @return bool */ public function filter($property); } If it returns true, the key/value pairs will be in the extracted arrays - if it returns false, you'll not see them again. Filter implementations Laminas\\Hydrator\\Filter\\GetFilter This filter is used in the ClassMethods hydrator to decide which getters will be extracted. It checks if the key to extract starts with get or the object contains a method beginning with get (e.g., Laminas\\Foo\\Bar::getFoo ). Laminas\\Hydrator\\Filter\\HasFilter This filter is used in the ClassMethods hydrator to decide which has methods will be extracted. It checks if the key to extract begins with has or the object contains a method beginning with has (e.g., Laminas\\Foo\\Bar::hasFoo ). Laminas\\Hydrator\\Filter\\IsFilter This filter is used in the ClassMethods hydrator to decide which is methods will be extracted. It checks if the key to extract begins with is or the object contains a method beginning with is (e.g., Laminas\\Foo\\Bar::isFoo ). Laminas\\Hydrator\\Filter\\MethodMatchFilter This filter allows you to omit methods during extraction that match the condition defined in the composite. The name of the method is specified in the constructor of this filter; the second parameter decides whether to use white or blacklisting to decide (whitelisting retains only the matching method, blacklist omits any matching method). The default is blacklisting - pass false to change the behavior. Laminas\\Hydrator\\Filter\\NumberOfParameterFilter This filter is used in the ClassMethods hydrator to check the number of parameters. By convention, the get , has and is methods do not get any parameters - but it may happen. You can add your own number of required parameters, simply add the number to the constructor. The default value is 0. If the method has more or fewer parameters than what the filter accepts, it will be omitted. Remove filters If you want to tell e.g. the ClassMethods hydrator, to not extract methods that start with is , remove the related filter: $hydrator = new ClassMethods(false); $hydrator-&gt;removeFilter('is'); After performing the above, the key/value pairs for is methods will not end up in your extracted array anymore. The filters can be used in any hydrator, but the ClassMethods hydrator is the only one, that has pre-registered filters: $this-&gt;filterComposite-&gt;addFilter('is', new IsFilter()); $this-&gt;filterComposite-&gt;addFilter('has', new HasFilter()); $this-&gt;filterComposite-&gt;addFilter('get', new GetFilter()); $this-&gt;filterComposite-&gt;addFilter( 'parameter', new NumberOfParameterFilter(), FilterComposite::CONDITION_AND ); If these are not appropriate for your object, you can unregister them as shown in the previous example. Add filters You can add filters to any hydrator that extends the AbstractHydrator . Filters can either implement FilterInterface , or simply be PHP callables: $hydrator-&gt;addFilter('len', function($property) { if (strlen($property) !== 3) { return false; } return true; }); By default, every filter you add will be added with a conditional or . If you want to add it with and (as the NumberOfParameterFilter that is added to the ClassMethods hydrator by default), provide the conditon as the third argument to addFilter : $hydrator-&gt;addFilter('len', function($property) { if (strlen($property) !== 3) { return false; } return true; }, FilterComposite::CONDITION_AND); One common use case for filters is to omit getters for values that you do not want to represent, such as a service manager instance: $hydrator-&gt;addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); The example above will exclude the getServiceManager() method and the servicemanager key from extraction, even if the get filter wants to add it. Use FilterComposite for complex filters FilterComposite implements FilterInterface as well, so you can add it as a regular filter to the hydrator. One benefit of this implementation is that you can add the filters with a condition and accomplish complex requirements using different composites with different conditions. You can pass the following conditions to the 3rd parameter, when you add a filter: Laminas\\Hydrator\\Filter\\FilterComposite::CONDITION_OR At the given level of the composite, at least one filter in that condition block has to return true to extract the value. Laminas\\Hydrator\\Filter\\FilterComposite::CONDITION_AND At the given level of the composite, all filters in that condition block must return true to extract the value. FilterComposite Examples This composition will have a similar logic as the if below: $composite = new FilterComposite(); $composite-&gt;addFilter('one', $condition1); $composite-&gt;addFilter('two', $condition2); $composite-&gt;addFilter('three', $condition3); $composite-&gt;addFilter('four', $condition4, FilterComposite::CONDITION_AND); $composite-&gt;addFilter('five', $condition5, FilterComposite::CONDITION_AND); // This is what's happening internally if ( ($condition1 || $condition2 || $condition3 ) &amp;&amp; ($condition4 &amp;&amp; $condition5 ) ) { //do extraction } If you only have one condition (e.g., only an and or or ) block, the other one will be completely ignored. A bit more complex filter can look like this: $composite = new FilterComposite(); $composite-&gt;addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $composite-&gt;addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $hydrator-&gt;addFilter('excludes', $composite, FilterComposite::CONDITION_AND); // Internal if (( // default composite inside the hydrator ($getFilter || $hasFilter || $isFilter ) &amp;&amp; ( $numberOfParameterFilter ) ) &amp;&amp; ( // new composite, added to the one above $serviceManagerFilter &amp;&amp; $eventManagerFilter ) ) { // do extraction } If you perform this on the ClassMethods hydrator, all getters will get extracted, except for getServiceManager() and getEventManager() . Using the provider interface FilterProviderInterface allows you to configure the behavior of the hydrator inside your objects. namespace Laminas\\Hydrator\\Filter; interface FilterProviderInterface { /** * Provides a filter for hydration * * @return FilterInterface */ public function getFilter(); } (The getFilter() method is automatically excluded from extract() .) If the extracted object implements the Laminas\\Hydrator\\Filter\\FilterProviderInterface , the returned FilterInterface instance can also be a FilterComposite . For example: Class Foo implements FilterProviderInterface { public function getFoo() { return 'foo'; } public function hasFoo() { return true; } public function getServiceManager() { return 'servicemanager'; } public function getEventManager() { return 'eventmanager'; } public function getFilter() { $composite = new FilterComposite(); $composite-&gt;addFilter('get', new GetFilter()); $exclusionComposite = new FilterComposite(); $exclusionComposite-&gt;addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $exclusionComposite-&gt;addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $composite-&gt;addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND); return $composite; } } $hydrator = new ClassMethods(false); $extractedArray = $hydrator-&gt;extract(new Foo()); $extractedArray will only have 'foo' =&gt; 'foo'; all other values are excluded from extraction. Note All pre-registered filters from the ClassMethods hydrator are ignored when this interface is used.","title":"Filters"},{"location":"v2/filter/#laminashydratorfilter","text":"Hydrator filters allow you to manipulate the behavior of the extract() operation. This is especially useful, if you want to omit some internals (e.g. getServiceManager() ) from the array representation. It comes with a helpful Composite implementation, and several filters for common use cases. The filters are composed in the AbstractHydrator , so you can start using them immediately in any custom extensions you write that extend that class. namespace Laminas\\Hydrator\\Filter; interface FilterInterface { /** * Should return true, if the given filter * does not match * * @param string $property The name of the property * @return bool */ public function filter($property); } If it returns true, the key/value pairs will be in the extracted arrays - if it returns false, you'll not see them again.","title":"Laminas\\Hydrator\\Filter"},{"location":"v2/filter/#filter-implementations","text":"","title":"Filter implementations"},{"location":"v2/filter/#remove-filters","text":"If you want to tell e.g. the ClassMethods hydrator, to not extract methods that start with is , remove the related filter: $hydrator = new ClassMethods(false); $hydrator-&gt;removeFilter('is'); After performing the above, the key/value pairs for is methods will not end up in your extracted array anymore. The filters can be used in any hydrator, but the ClassMethods hydrator is the only one, that has pre-registered filters: $this-&gt;filterComposite-&gt;addFilter('is', new IsFilter()); $this-&gt;filterComposite-&gt;addFilter('has', new HasFilter()); $this-&gt;filterComposite-&gt;addFilter('get', new GetFilter()); $this-&gt;filterComposite-&gt;addFilter( 'parameter', new NumberOfParameterFilter(), FilterComposite::CONDITION_AND ); If these are not appropriate for your object, you can unregister them as shown in the previous example.","title":"Remove filters"},{"location":"v2/filter/#add-filters","text":"You can add filters to any hydrator that extends the AbstractHydrator . Filters can either implement FilterInterface , or simply be PHP callables: $hydrator-&gt;addFilter('len', function($property) { if (strlen($property) !== 3) { return false; } return true; }); By default, every filter you add will be added with a conditional or . If you want to add it with and (as the NumberOfParameterFilter that is added to the ClassMethods hydrator by default), provide the conditon as the third argument to addFilter : $hydrator-&gt;addFilter('len', function($property) { if (strlen($property) !== 3) { return false; } return true; }, FilterComposite::CONDITION_AND); One common use case for filters is to omit getters for values that you do not want to represent, such as a service manager instance: $hydrator-&gt;addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); The example above will exclude the getServiceManager() method and the servicemanager key from extraction, even if the get filter wants to add it.","title":"Add filters"},{"location":"v2/filter/#use-filtercomposite-for-complex-filters","text":"FilterComposite implements FilterInterface as well, so you can add it as a regular filter to the hydrator. One benefit of this implementation is that you can add the filters with a condition and accomplish complex requirements using different composites with different conditions. You can pass the following conditions to the 3rd parameter, when you add a filter:","title":"Use FilterComposite for complex filters"},{"location":"v2/filter/#using-the-provider-interface","text":"FilterProviderInterface allows you to configure the behavior of the hydrator inside your objects. namespace Laminas\\Hydrator\\Filter; interface FilterProviderInterface { /** * Provides a filter for hydration * * @return FilterInterface */ public function getFilter(); } (The getFilter() method is automatically excluded from extract() .) If the extracted object implements the Laminas\\Hydrator\\Filter\\FilterProviderInterface , the returned FilterInterface instance can also be a FilterComposite . For example: Class Foo implements FilterProviderInterface { public function getFoo() { return 'foo'; } public function hasFoo() { return true; } public function getServiceManager() { return 'servicemanager'; } public function getEventManager() { return 'eventmanager'; } public function getFilter() { $composite = new FilterComposite(); $composite-&gt;addFilter('get', new GetFilter()); $exclusionComposite = new FilterComposite(); $exclusionComposite-&gt;addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $exclusionComposite-&gt;addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $composite-&gt;addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND); return $composite; } } $hydrator = new ClassMethods(false); $extractedArray = $hydrator-&gt;extract(new Foo()); $extractedArray will only have 'foo' =&gt; 'foo'; all other values are excluded from extraction.","title":"Using the provider interface"},{"location":"v2/quick-start/","text":"laminas-hydrator Hydration is the act of populating an object from a set of data. laminas-hydrator is a simple component to provide mechanisms both for hydrating objects, as well as extracting data sets from them. The component consists of interfaces, and several implementations for common use cases. Base Interfaces ExtractionInterface namespace Laminas\\Hydrator; interface ExtractionInterface { / * Extract values from an object * * @param object $object * @return array */ public function extract($object); } HydrationInterface namespace Laminas\\Hydrator; interface HydrationInterface { / * Hydrate $object with the provided $data. * * @param array $data * @param object $object * @return object */ public function hydrate(array $data, $object); } HydratorInterface namespace Laminas\\Hydrator; interface HydratorInterface extends ExtractionInterface, HydrationInterface { } Usage Usage involves instantiating the hydrator, and then passing information to it. use Laminas\\Hydrator; $hydrator = new Hydrator\\ArraySerializable(); // To hydrate an object from values in an array: $object = $hydrator-&gt;hydrate($data, new ArrayObject()); // or, going the other way and extracting the values from an object as an array: $data = $hydrator-&gt;extract($object); Available Implementations Laminas\\Hydrator\\ArraySerializable Follows the definition of ArrayObject . Objects must implement either the exchangeArray() or populate() methods to support hydration, and the getArrayCopy() method to support extraction. Laminas\\Hydrator\\ClassMethods Any data key matching a setter method will be called in order to hydrate; any method matching a getter method will be called for extraction. Laminas\\Hydrator\\DelegatingHydrator Composes a hydrator locator, and will delegate hydrate() and extract() calls to the appropriate one based upon the class name of the object being operated on. // Instantiate each hydrator you wish to delegate to $albumHydrator = new Laminas\\Hydrator\\ClassMethods; $artistHydrator = new Laminas\\Hydrator\\ClassMethods; // Map the entity class name to the hydrator using the HydratorPluginManager. // In this case we have two entity classes, \"Album\" and \"Artist\". $hydrators = new Laminas\\Hydrator\\HydratorPluginManager; $hydrators-&gt;setService('Album', $albumHydrator); $hydrators-&gt;setService('Artist', $artistHydrator); // Create the DelegatingHydrator and tell it to use our configured hydrator locator $delegating = new Laminas\\Hydrator\\DelegatingHydrator($hydrators); // Now we can use $delegating to hydrate or extract any supported object $array = $delegating-&gt;extract(new Artist); $artist = $delegating-&gt;hydrate($data, new Artist); Laminas\\Hydrator\\ObjectProperty Any data key matching a publicly accessible property will be hydrated; any public properties will be used for extraction. Laminas\\Hydrator\\Reflection Similar to the ObjectProperty hydrator, but uses PHP's reflection API to hydrate or extract properties of any visibility. Any data key matching an existing property will be hydrated; any existing properties will be used for extraction.","title":"Quick Start"},{"location":"v2/quick-start/#laminas-hydrator","text":"Hydration is the act of populating an object from a set of data. laminas-hydrator is a simple component to provide mechanisms both for hydrating objects, as well as extracting data sets from them. The component consists of interfaces, and several implementations for common use cases.","title":"laminas-hydrator"},{"location":"v2/quick-start/#base-interfaces","text":"","title":"Base Interfaces"},{"location":"v2/quick-start/#usage","text":"Usage involves instantiating the hydrator, and then passing information to it. use Laminas\\Hydrator; $hydrator = new Hydrator\\ArraySerializable(); // To hydrate an object from values in an array: $object = $hydrator-&gt;hydrate($data, new ArrayObject()); // or, going the other way and extracting the values from an object as an array: $data = $hydrator-&gt;extract($object);","title":"Usage"},{"location":"v2/quick-start/#available-implementations","text":"","title":"Available Implementations"},{"location":"v2/strategy/","text":"Laminas\\Hydrator\\Strategy You can add Laminas\\Hydrator\\Strategy\\StrategyInterface to any of the hydrators (except if it extends Laminas\\Hydrator\\AbstractHydrator or implements Laminas\\Hydrator\\HydratorInterface and Laminas\\Hydrator\\Strategy\\StrategyEnabledInterface ) to manipulate the way how they behave on extract() and hydrate() for specific key / value pairs. This is the interface that needs to be implemented: namespace Laminas\\Hydrator\\Strategy; interface StrategyInterface { /** * Converts the given value so that it can be extracted by the hydrator. * * @param mixed $value The original value. * @return mixed Returns the value that should be extracted. */ public function extract($value); /** * Converts the given value so that it can be hydrated by the hydrator. * * @param mixed $value The original value. * @return mixed Returns the value that should be hydrated. */ public function hydrate($value); } This interface is similar to Laminas\\Hydrator\\HydratorInterface ; the reason is that strategies provide a proxy implementation for hydrate() and extract() . Adding strategies to the hydrators To allow strategies within your hydrator, Laminas\\Hydrator\\Strategy\\StrategyEnabledInterface provides the following methods: namespace Laminas\\Hydrator; use Laminas\\Hydrator\\Strategy\\StrategyInterface; interface StrategyEnabledInterface { /** * Adds the given strategy under the given name. * * @param string $name The name of the strategy to register. * @param StrategyInterface $strategy The strategy to register. * @return HydratorInterface */ public function addStrategy($name, StrategyInterface $strategy); /** * Gets the strategy with the given name. * * @param string $name The name of the strategy to get. * @return StrategyInterface */ public function getStrategy($name); /** * Checks if the strategy with the given name exists. * * @param string $name The name of the strategy to check for. * @return bool */ public function hasStrategy($name); /** * Removes the strategy with the given name. * * @param string $name The name of the strategy to remove. * @return HydratorInterface */ public function removeStrategy($name); } Every hydrator shipped by default provides this functionality; AbstractHydrator fully implements it as well. As such, if you want to use this functionality in your own hydrators, you should extend AbstractHydrator . Available implementations Laminas\\Hydrator\\Strategy\\BooleanStrategy This strategy converts values into Booleans and vice versa. It expects two arguments at the constructor, which are used to define value maps for true and false . Laminas\\Hydrator\\Strategy\\ClosureStrategy This is a strategy that allows you to pass in options for: hydrate , a callback to be called when hydrating a value, and extract , a callback to be called when extracting a value. Laminas\\Hydrator\\Strategy\\DateTimeFormatterStrategy DateTimeFormatterStrategy provides bidirectional conversion between strings and DateTime instances. The input and output formats can be provided as constructor arguments. As of version 2.4.1, this strategy now allows DateTime formats that use ! to prepend the format, or | or + to append it; these ensure that, during hydration, the new DateTime instance created will set the time element accordingly. As a specific example, Y-m-d| will drop the time component, ensuring comparisons are based on a midnight time value. Laminas\\Hydrator\\Strategy\\DefaultStrategy The DefaultStrategy simply proxies everything through, without performing any conversion of values. Laminas\\Hydrator\\Strategy\\ExplodeStrategy This strategy is a wrapper around PHP's implode() and explode() functions. The delimiter and a limit can be provided to the constructor; the limit will only be used for extract operations. Laminas\\Hydrator\\Strategy\\SerializableStrategy SerializableStrategy provides the functionality backing Laminas\\Hydrator\\ArraySerializable . You can use it with custom implementations for Laminas\\Serializer\\Adapter\\AdapterInterface if you want to as well. Laminas\\Hydrator\\Strategy\\StrategyChain This strategy takes an array of StrategyInterface instances and iterates over them when performing extract() and hydrate() operations. Each operates on the return value of the previous, allowing complex operations based on smaller, single-purpose strategies. Writing custom strategies The following example, while not terribly useful, will provide you with the basics for writing your own strategies, as well as provide ideas as to where and when to use them. This strategy simply transforms the value for the defined key using str_rot13() during both the extract() and hydrate() operations: class Rot13Strategy implements StrategyInterface { public function extract($value) { return str_rot13($value); } public function hydrate($value) { return str_rot13($value); } } This is the example class with which we want to use the hydrator example: class Foo { protected $foo = null; protected $bar = null; public function getFoo() { return $this-&gt;foo; } public function setFoo($foo) { $this-&gt;foo = $foo; } public function getBar() { return $this-&gt;bar; } public function setBar($bar) { $this-&gt;bar = $bar; } } Now, we'll add the rot13 strategy to the method getFoo() and setFoo($foo) : $foo = new Foo(); $foo-&gt;setFoo('bar'); $foo-&gt;setBar('foo'); $hydrator = new ClassMethods(); $hydrator-&gt;addStrategy('foo', new Rot13Strategy()); When you use the hydrator to extract an array for the object $foo , you'll receive the following: $extractedArray = $hydrator-&gt;extract($foo); // array(2) { // [\"foo\"]=&gt; // string(3) \"one\" // [\"bar\"]=&gt; // string(3) \"foo\" // } And when hydrating a new Foo instance: $hydrator-&gt;hydrate($extractedArray, $foo) // object(Foo)#2 (2) { // [\"foo\":protected]=&gt; // string(3) \"bar\" // [\"bar\":protected]=&gt; // string(3) \"foo\" // }","title":"Strategies"},{"location":"v2/strategy/#laminashydratorstrategy","text":"You can add Laminas\\Hydrator\\Strategy\\StrategyInterface to any of the hydrators (except if it extends Laminas\\Hydrator\\AbstractHydrator or implements Laminas\\Hydrator\\HydratorInterface and Laminas\\Hydrator\\Strategy\\StrategyEnabledInterface ) to manipulate the way how they behave on extract() and hydrate() for specific key / value pairs. This is the interface that needs to be implemented: namespace Laminas\\Hydrator\\Strategy; interface StrategyInterface { /** * Converts the given value so that it can be extracted by the hydrator. * * @param mixed $value The original value. * @return mixed Returns the value that should be extracted. */ public function extract($value); /** * Converts the given value so that it can be hydrated by the hydrator. * * @param mixed $value The original value. * @return mixed Returns the value that should be hydrated. */ public function hydrate($value); } This interface is similar to Laminas\\Hydrator\\HydratorInterface ; the reason is that strategies provide a proxy implementation for hydrate() and extract() .","title":"Laminas\\Hydrator\\Strategy"},{"location":"v2/strategy/#adding-strategies-to-the-hydrators","text":"To allow strategies within your hydrator, Laminas\\Hydrator\\Strategy\\StrategyEnabledInterface provides the following methods: namespace Laminas\\Hydrator; use Laminas\\Hydrator\\Strategy\\StrategyInterface; interface StrategyEnabledInterface { /** * Adds the given strategy under the given name. * * @param string $name The name of the strategy to register. * @param StrategyInterface $strategy The strategy to register. * @return HydratorInterface */ public function addStrategy($name, StrategyInterface $strategy); /** * Gets the strategy with the given name. * * @param string $name The name of the strategy to get. * @return StrategyInterface */ public function getStrategy($name); /** * Checks if the strategy with the given name exists. * * @param string $name The name of the strategy to check for. * @return bool */ public function hasStrategy($name); /** * Removes the strategy with the given name. * * @param string $name The name of the strategy to remove. * @return HydratorInterface */ public function removeStrategy($name); } Every hydrator shipped by default provides this functionality; AbstractHydrator fully implements it as well. As such, if you want to use this functionality in your own hydrators, you should extend AbstractHydrator .","title":"Adding strategies to the hydrators"},{"location":"v2/strategy/#available-implementations","text":"","title":"Available implementations"},{"location":"v2/strategy/#writing-custom-strategies","text":"The following example, while not terribly useful, will provide you with the basics for writing your own strategies, as well as provide ideas as to where and when to use them. This strategy simply transforms the value for the defined key using str_rot13() during both the extract() and hydrate() operations: class Rot13Strategy implements StrategyInterface { public function extract($value) { return str_rot13($value); } public function hydrate($value) { return str_rot13($value); } } This is the example class with which we want to use the hydrator example: class Foo { protected $foo = null; protected $bar = null; public function getFoo() { return $this-&gt;foo; } public function setFoo($foo) { $this-&gt;foo = $foo; } public function getBar() { return $this-&gt;bar; } public function setBar($bar) { $this-&gt;bar = $bar; } } Now, we'll add the rot13 strategy to the method getFoo() and setFoo($foo) : $foo = new Foo(); $foo-&gt;setFoo('bar'); $foo-&gt;setBar('foo'); $hydrator = new ClassMethods(); $hydrator-&gt;addStrategy('foo', new Rot13Strategy()); When you use the hydrator to extract an array for the object $foo , you'll receive the following: $extractedArray = $hydrator-&gt;extract($foo); // array(2) { // [\"foo\"]=&gt; // string(3) \"one\" // [\"bar\"]=&gt; // string(3) \"foo\" // } And when hydrating a new Foo instance: $hydrator-&gt;hydrate($extractedArray, $foo) // object(Foo)#2 (2) { // [\"foo\":protected]=&gt; // string(3) \"bar\" // [\"bar\":protected]=&gt; // string(3) \"foo\" // }","title":"Writing custom strategies"},{"location":"v2/naming-strategy/composite-naming-strategy/","text":"CompositeNamingStrategy Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy allows you to specify which naming strategy should be used for each key encountered during hydration or extraction. Basic Usage When invoked, the following composite strategy will extract the property bar to the array key foo (using the MapNamingStrategy ), and the property barBat to the array key bar_bat (using the UnderscoreNamingStrategy ): class Foo { public $bar; public $barBat; } $mapStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' =&gt; 'bar' ]); $underscoreNamingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ 'bar' =&gt; $mapStrategy, 'barBat' =&gt; $underscoreNamingStrategy, ]); $hydrator = new Laminas\\Hydrator\\ObjectProperty(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $foo-&gt;bar = 123; $foo-&gt;barBat = 42; print_r($foo); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 [bar_bat] =&gt; 42 ) Unfortunately, the CompositeNamingStrategy can only be used for extraction as it will not know how to handle the keys necessary for hydration ( foo and bar_bat , respectively). To rectify this we have to cover the keys for both hydration and extraction in our composite strategy: class Foo { public $bar; public $barBat; } $mapStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' =&gt; 'bar' ]); $underscoreNamingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ // Define both directions for the foo =&gt; bar mapping 'bar' =&gt; $mapStrategy, 'foo' =&gt; $mapStrategy, // Define both directions for the barBat =&gt; bar_bat mapping 'barBat' =&gt; $underscoreNamingStrategy, 'bar_bat' =&gt; $underscoreNamingStrategy, ]); $hydrator = new Laminas\\Hydrator\\ObjectProperty(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $foo-&gt;bar = 123; $foo-&gt;barBat = 42; $array = $hydrator-&gt;extract($foo); print_r($foo); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 ) print_r($array); // Array ( [foo] =&gt; 123 [bar_bat] =&gt; 42 ) $foo2 = new Foo(); $hydrator-&gt;hydrate($array, $foo2); print_r($foo2); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 )","title":"Composite"},{"location":"v2/naming-strategy/composite-naming-strategy/#compositenamingstrategy","text":"Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy allows you to specify which naming strategy should be used for each key encountered during hydration or extraction.","title":"CompositeNamingStrategy"},{"location":"v2/naming-strategy/composite-naming-strategy/#basic-usage","text":"When invoked, the following composite strategy will extract the property bar to the array key foo (using the MapNamingStrategy ), and the property barBat to the array key bar_bat (using the UnderscoreNamingStrategy ): class Foo { public $bar; public $barBat; } $mapStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' =&gt; 'bar' ]); $underscoreNamingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ 'bar' =&gt; $mapStrategy, 'barBat' =&gt; $underscoreNamingStrategy, ]); $hydrator = new Laminas\\Hydrator\\ObjectProperty(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $foo-&gt;bar = 123; $foo-&gt;barBat = 42; print_r($foo); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 [bar_bat] =&gt; 42 ) Unfortunately, the CompositeNamingStrategy can only be used for extraction as it will not know how to handle the keys necessary for hydration ( foo and bar_bat , respectively). To rectify this we have to cover the keys for both hydration and extraction in our composite strategy: class Foo { public $bar; public $barBat; } $mapStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' =&gt; 'bar' ]); $underscoreNamingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ // Define both directions for the foo =&gt; bar mapping 'bar' =&gt; $mapStrategy, 'foo' =&gt; $mapStrategy, // Define both directions for the barBat =&gt; bar_bat mapping 'barBat' =&gt; $underscoreNamingStrategy, 'bar_bat' =&gt; $underscoreNamingStrategy, ]); $hydrator = new Laminas\\Hydrator\\ObjectProperty(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $foo-&gt;bar = 123; $foo-&gt;barBat = 42; $array = $hydrator-&gt;extract($foo); print_r($foo); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 ) print_r($array); // Array ( [foo] =&gt; 123 [bar_bat] =&gt; 42 ) $foo2 = new Foo(); $hydrator-&gt;hydrate($array, $foo2); print_r($foo2); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 )","title":"Basic Usage"},{"location":"v2/naming-strategy/identity-naming-strategy/","text":"IdentityNamingStrategy Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy uses the keys provided to it for hydration and extraction. Basic Usage $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); echo $namingStrategy-&gt;hydrate('foo'); // outputs: foo echo $namingStrategy-&gt;extract('bar'); // outputs: bar This strategy can be used in hydrators as well: class Foo { public $foo; } $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); $hydrator = new Laminas\\Hydrator\\ObjectProperty(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator-&gt;hydrate(array('foo' =&gt; 123), $foo); print_r($foo); // Foo Object ( [foo] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 )","title":"Identity"},{"location":"v2/naming-strategy/identity-naming-strategy/#identitynamingstrategy","text":"Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy uses the keys provided to it for hydration and extraction.","title":"IdentityNamingStrategy"},{"location":"v2/naming-strategy/identity-naming-strategy/#basic-usage","text":"$namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); echo $namingStrategy-&gt;hydrate('foo'); // outputs: foo echo $namingStrategy-&gt;extract('bar'); // outputs: bar This strategy can be used in hydrators as well: class Foo { public $foo; } $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); $hydrator = new Laminas\\Hydrator\\ObjectProperty(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator-&gt;hydrate(array('foo' =&gt; 123), $foo); print_r($foo); // Foo Object ( [foo] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 )","title":"Basic Usage"},{"location":"v2/naming-strategy/map-naming-strategy/","text":"MapNamingStrategy Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy allows you to provide a map of keys to use when hydrating and extracting; the map will translate the key based on the direction. Basic Usage $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy(array( 'foo' =&gt; 'bar', 'baz' =&gt; 'bash' )); echo $namingStrategy-&gt;hydrate('foo'); // outputs: bar echo $namingStrategy-&gt;hydrate('baz'); // outputs: bash echo $namingStrategy-&gt;extract('bar'); // outputs: foo echo $namingStrategy-&gt;extract('bash'); // outputs: baz This strategy can be used in hydrators to dictate how keys should be mapped: class Foo { public $bar; } $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' =&gt; 'bar', 'baz' =&gt; 'bash' ]); $hydrator = new Laminas\\Hydrator\\ObjectProperty(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator-&gt;hydrate(['foo' =&gt; 123], $foo); print_r($foo); // Foo Object ( [bar] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 )","title":"Mapping"},{"location":"v2/naming-strategy/map-naming-strategy/#mapnamingstrategy","text":"Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy allows you to provide a map of keys to use when hydrating and extracting; the map will translate the key based on the direction.","title":"MapNamingStrategy"},{"location":"v2/naming-strategy/map-naming-strategy/#basic-usage","text":"$namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy(array( 'foo' =&gt; 'bar', 'baz' =&gt; 'bash' )); echo $namingStrategy-&gt;hydrate('foo'); // outputs: bar echo $namingStrategy-&gt;hydrate('baz'); // outputs: bash echo $namingStrategy-&gt;extract('bar'); // outputs: foo echo $namingStrategy-&gt;extract('bash'); // outputs: baz This strategy can be used in hydrators to dictate how keys should be mapped: class Foo { public $bar; } $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' =&gt; 'bar', 'baz' =&gt; 'bash' ]); $hydrator = new Laminas\\Hydrator\\ObjectProperty(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator-&gt;hydrate(['foo' =&gt; 123], $foo); print_r($foo); // Foo Object ( [bar] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 )","title":"Basic Usage"},{"location":"v2/naming-strategy/underscore-naming-strategy/","text":"UnderscoreNamingStrategy Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy converts snake case strings (e.g. foo_bar_baz ) to camel-case strings (e.g. fooBarBaz ) and vice versa. Basic Usage $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); echo $namingStrategy-&gt;extract('foo_bar'); // outputs: foo_bar echo $namingStrategy-&gt;extract('Foo_Bar'); // outputs: foo_bar echo $namingStrategy-&gt;extract('FooBar'); // outputs: foo_bar echo $namingStrategy-&gt;hydrate('fooBar'); // outputs: fooBar echo $namingStrategy-&gt;hydrate('FooBar'); // outputs: fooBar echo $namingStrategy-&gt;hydrate('Foo_Bar'); // outputs: fooBar This strategy can be used in hydrators to dictate how keys should be mapped. class Foo { public $fooBar; } $hydrator = new Laminas\\Hydrator\\ObjectProperty(); $hydrator-&gt;setNamingStrategy(new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy()); $foo = new Foo(); $hydrator-&gt;hydrate(['foo_bar' =&gt; 123], $foo); print_r($foo); // Foo Object ( [fooBar] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo_bar] =&gt; 123 )","title":"Underscore Mapping"},{"location":"v2/naming-strategy/underscore-naming-strategy/#underscorenamingstrategy","text":"Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy converts snake case strings (e.g. foo_bar_baz ) to camel-case strings (e.g. fooBarBaz ) and vice versa.","title":"UnderscoreNamingStrategy"},{"location":"v2/naming-strategy/underscore-naming-strategy/#basic-usage","text":"$namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); echo $namingStrategy-&gt;extract('foo_bar'); // outputs: foo_bar echo $namingStrategy-&gt;extract('Foo_Bar'); // outputs: foo_bar echo $namingStrategy-&gt;extract('FooBar'); // outputs: foo_bar echo $namingStrategy-&gt;hydrate('fooBar'); // outputs: fooBar echo $namingStrategy-&gt;hydrate('FooBar'); // outputs: fooBar echo $namingStrategy-&gt;hydrate('Foo_Bar'); // outputs: fooBar This strategy can be used in hydrators to dictate how keys should be mapped. class Foo { public $fooBar; } $hydrator = new Laminas\\Hydrator\\ObjectProperty(); $hydrator-&gt;setNamingStrategy(new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy()); $foo = new Foo(); $hydrator-&gt;hydrate(['foo_bar' =&gt; 123], $foo); print_r($foo); // Foo Object ( [fooBar] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo_bar] =&gt; 123 )","title":"Basic Usage"},{"location":"v3/aggregate/","text":"AggregateHydrator Laminas\\Hydrator\\Aggregate\\AggregateHydrator is an implementation of Laminas\\Hydrator\\HydratorInterface that composes multiple hydrators via event listeners. You typically want to use an aggregate hydrator when you want to hydrate or extract data from complex objects that implement multiple interfaces, and therefore need multiple hydrators to handle that in subsequent steps. Installation requirements The AggregateHydrator depends on the laminas-eventmanager component, so be sure to have it installed before getting started: $ composer require laminas/laminas-eventmanager Basic usage A simple use case may be hydrating a BlogPost object, which contains data for the user that created it, the time it was created, the current publishing status, etc: use Laminas\\Hydrator\\Aggregate\\AggregateHydrator; $hydrator = new AggregateHydrator(); // attach the various hydrators capable of handling simpler interfaces $hydrator-&gt;add(new My\\BlogPostHydrator()); $hydrator-&gt;add(new My\\UserAwareObjectHydrator()); $hydrator-&gt;add(new My\\TimestampedObjectHydrator()); $hydrator-&gt;add(new My\\PublishableObjectHydrator()); // ... // Now retrieve the BlogPost object // ... // you can now extract complex data from a blogpost $data = $hydrator-&gt;extract($blogPost); // or you can fill the object with complex data $blogPost = $hydrator-&gt;hydrate($data, $blogPost); Hydrator priorities AggregateHydrator::add has a second optional argument, $priority . If you have two or more hydrators that conflict with each other for same data keys, you may decide which one to execute first or last by passing a higher or lower integer priority, respectively, to this argument. In order to work with this logic, each of the hydrators that are attached should ignore any unknown object type passed in: namespace My; use Laminas\\Hydrator\\HydratorInterface class BlogPostHydrator implements HydratorInterface { public function hydrate($data, $object) { if (! $object instanceof BlogPost) { return $object; } // ... continue hydration ... } public function extract($object) { if (! $object instanceof BlogPost) { return array(); } // ... continue extraction ... } } Advanced use cases Since the AggregateHydrator is event-driven, you can use the EventManager API to tweak its behaviour. Common use cases include: Removal of hydrated data keys (passwords/confidential information) depending on business rules. Caching of the hydration/extraction process. Transformations on extracted data, for compatibility with third-party APIs. In the following example, a cache listener is introduced to speed up hydration, which can be very useful when the same data is requested multiple times: use Laminas\\Hydrator\\Aggregate\\AggregateHydrator; use Laminas\\Hydrator\\Aggregate\\ExtractEvent; use Laminas\\Cache\\Storage\\Adapter\\Memory; $hydrator = new AggregateHydrator(); // Attach the various hydrators: $hydrator-&gt;add(new My\\BlogPostHydrator()); $hydrator-&gt;add(new My\\UserAwareObjectHydrator()); $hydrator-&gt;add(new My\\TimestampedObjectHydrator()); $hydrator-&gt;add(new My\\PublishableObjectHydrator()); // ... $cache = new Memory(); $cacheReadListener = function (ExtractEvent $event) use ($cache) { $object = $event-&gt;getExtractionObject(); if (! $object instanceof BlogPost) { return; } if ($cache-&gt;hasItem($object-&gt;getId())) { $event-&gt;setExtractedData($cache-&gt;getItem($object-&gt;getId())); $event-&gt;stopPropagation(); } }; $cacheWriteListener = function (ExtractEvent $event) use ($cache) { $object = $event-&gt;getExtractionObject(); if (! $object instanceof BlogPost) { return; } $cache-&gt;setItem($object-&gt;getId(), $event-&gt;getExtractedData()); }; // Attaching a high priority listener executed before extraction logic: $eventManager = $hydrator-&gt;getEventManager(); $eventManager()-&gt;attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000); // Attaching a low priority listener executed after extraction logic: $eventManager()-&gt;attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000); With an aggregate hydrator configured in this way, any $hydrator-&gt;extract($blogPost) operation will be cached.","title":"Aggregates"},{"location":"v3/aggregate/#aggregatehydrator","text":"Laminas\\Hydrator\\Aggregate\\AggregateHydrator is an implementation of Laminas\\Hydrator\\HydratorInterface that composes multiple hydrators via event listeners. You typically want to use an aggregate hydrator when you want to hydrate or extract data from complex objects that implement multiple interfaces, and therefore need multiple hydrators to handle that in subsequent steps.","title":"AggregateHydrator"},{"location":"v3/aggregate/#installation-requirements","text":"The AggregateHydrator depends on the laminas-eventmanager component, so be sure to have it installed before getting started: $ composer require laminas/laminas-eventmanager","title":"Installation requirements"},{"location":"v3/aggregate/#basic-usage","text":"A simple use case may be hydrating a BlogPost object, which contains data for the user that created it, the time it was created, the current publishing status, etc: use Laminas\\Hydrator\\Aggregate\\AggregateHydrator; $hydrator = new AggregateHydrator(); // attach the various hydrators capable of handling simpler interfaces $hydrator-&gt;add(new My\\BlogPostHydrator()); $hydrator-&gt;add(new My\\UserAwareObjectHydrator()); $hydrator-&gt;add(new My\\TimestampedObjectHydrator()); $hydrator-&gt;add(new My\\PublishableObjectHydrator()); // ... // Now retrieve the BlogPost object // ... // you can now extract complex data from a blogpost $data = $hydrator-&gt;extract($blogPost); // or you can fill the object with complex data $blogPost = $hydrator-&gt;hydrate($data, $blogPost);","title":"Basic usage"},{"location":"v3/aggregate/#advanced-use-cases","text":"Since the AggregateHydrator is event-driven, you can use the EventManager API to tweak its behaviour. Common use cases include: Removal of hydrated data keys (passwords/confidential information) depending on business rules. Caching of the hydration/extraction process. Transformations on extracted data, for compatibility with third-party APIs. In the following example, a cache listener is introduced to speed up hydration, which can be very useful when the same data is requested multiple times: use Laminas\\Hydrator\\Aggregate\\AggregateHydrator; use Laminas\\Hydrator\\Aggregate\\ExtractEvent; use Laminas\\Cache\\Storage\\Adapter\\Memory; $hydrator = new AggregateHydrator(); // Attach the various hydrators: $hydrator-&gt;add(new My\\BlogPostHydrator()); $hydrator-&gt;add(new My\\UserAwareObjectHydrator()); $hydrator-&gt;add(new My\\TimestampedObjectHydrator()); $hydrator-&gt;add(new My\\PublishableObjectHydrator()); // ... $cache = new Memory(); $cacheReadListener = function (ExtractEvent $event) use ($cache) { $object = $event-&gt;getExtractionObject(); if (! $object instanceof BlogPost) { return; } if ($cache-&gt;hasItem($object-&gt;getId())) { $event-&gt;setExtractedData($cache-&gt;getItem($object-&gt;getId())); $event-&gt;stopPropagation(); } }; $cacheWriteListener = function (ExtractEvent $event) use ($cache) { $object = $event-&gt;getExtractionObject(); if (! $object instanceof BlogPost) { return; } $cache-&gt;setItem($object-&gt;getId(), $event-&gt;getExtractedData()); }; // Attaching a high priority listener executed before extraction logic: $eventManager = $hydrator-&gt;getEventManager(); $eventManager()-&gt;attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000); // Attaching a low priority listener executed after extraction logic: $eventManager()-&gt;attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000); With an aggregate hydrator configured in this way, any $hydrator-&gt;extract($blogPost) operation will be cached.","title":"Advanced use cases"},{"location":"v3/filter/","text":"Laminas\\Hydrator\\Filter Hydrator filters allow you to manipulate the behavior of the extract() operation. This is especially useful, if you want to omit some internals (e.g. getServiceManager() ) from the array representation. It comes with a helpful Composite implementation, and several filters for common use cases. The filters are composed in the AbstractHydrator , so you can start using them immediately in any custom extensions you write that extend that class. namespace Laminas\\Hydrator\\Filter; interface FilterInterface { /** * Should return true, if the given filter does not match. */ public function filter(string $property) : bool; } If it returns true, the key/value pairs will be in the extracted arrays - if it returns false, you'll not see them again. Filter implementations Laminas\\Hydrator\\Filter\\GetFilter This filter is used in the ClassMethodsHydrator to decide which getters will be extracted. It checks if the key to extract starts with get or the object contains a method beginning with get (e.g., Laminas\\Foo\\Bar::getFoo ). Laminas\\Hydrator\\Filter\\HasFilter This filter is used in the ClassMethodsHydrator to decide which has methods will be extracted. It checks if the key to extract begins with has or the object contains a method beginning with has (e.g., Laminas\\Foo\\Bar::hasFoo ). Laminas\\Hydrator\\Filter\\IsFilter This filter is used in the ClassMethodsHydrator to decide which is methods will be extracted. It checks if the key to extract begins with is or the object contains a method beginning with is (e.g., Laminas\\Foo\\Bar::isFoo ). Laminas\\Hydrator\\Filter\\MethodMatchFilter This filter allows you to omit methods during extraction that match the condition defined in the composite. The name of the method is specified in the constructor of this filter; the second parameter decides whether to use white or blacklisting to decide (whitelisting retains only the matching method, blacklist omits any matching method). The default is blacklisting - pass false to change the behavior. Laminas\\Hydrator\\Filter\\NumberOfParameterFilter This filter is used in the ClassMethodsHydrator to check the number of parameters. By convention, the get , has and is methods do not get any parameters - but it may happen. You can add your own number of required parameters, simply add the number to the constructor. The default value is 0. If the method has more or fewer parameters than what the filter accepts, it will be omitted. Use FilterComposite for complex filters FilterComposite implements FilterInterface as well, so you can add it as a regular filter to the hydrator. One benefit of this implementation is that you can add the filters with a condition and accomplish complex requirements using different filters with different conditions. You can pass the following conditions to the 3rd parameter, when you add a filter: Laminas\\Hydrator\\Filter\\FilterComposite::CONDITION_OR At the given level of the composite, at least one filter set using CONDITION_OR must return true to extract the value. Laminas\\Hydrator\\Filter\\FilterComposite::CONDITION_AND At the given level of the composite, all filters set using CONDITION_AND must return true to extract the value. FilterComposite Examples To illustrate how conditions apply when composing filters, consider the following set of filters: $composite = new FilterComposite(); $composite-&gt;addFilter('one', $condition1); $composite-&gt;addFilter('two', $condition2); $composite-&gt;addFilter('three', $condition3); $composite-&gt;addFilter('four', $condition4, FilterComposite::CONDITION_AND); $composite-&gt;addFilter('five', $condition5, FilterComposite::CONDITION_AND); The above is roughly equivalent to the following conditional: // This is what's happening internally if ( ($condition1 || $condition2 || $condition3 ) &amp;&amp; ($condition4 &amp;&amp; $condition5 ) ) { // do extraction } If you only have one condition block (e.g., only AND or OR filters), the other condition type will be completely ignored. A bit more complex filter can look like this: $composite = new FilterComposite(); $composite-&gt;addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $composite-&gt;addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $hydrator-&gt;addFilter('excludes', $composite, FilterComposite::CONDITION_AND); // Internal if (( // default composite inside the ClassMethodsHydrator: ($getFilter || $hasFilter || $isFilter ) &amp;&amp; ( $numberOfParameterFilter ) ) &amp;&amp; ( // new composite, added to the one above $serviceManagerFilter &amp;&amp; $eventManagerFilter ) ) { // do extraction } If you perform this on the ClassMethodsHydrator , all getters will get extracted, except for getServiceManager() and getEventManager() . Using the provider interface Laminas\\Hydrator\\Filter\\FilterProviderInterface allows you to configure the behavior of the hydrator inside your objects. namespace Laminas\\Hydrator\\Filter; interface FilterProviderInterface { /** * Provides a filter for hydration * * @return FilterInterface */ public function getFilter(); } (The getFilter() method is automatically excluded from extract() .) If the extracted object implements the Laminas\\Hydrator\\Filter\\FilterProviderInterface , the returned FilterInterface instance can also be a FilterComposite . For example: Class Foo implements FilterProviderInterface { public function getFoo() { return 'foo'; } public function hasFoo() { return true; } public function getServiceManager() { return 'servicemanager'; } public function getEventManager() { return 'eventmanager'; } public function getFilter() { $composite = new FilterComposite(); $composite-&gt;addFilter('get', new GetFilter()); $exclusionComposite = new FilterComposite(); $exclusionComposite-&gt;addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $exclusionComposite-&gt;addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $composite-&gt;addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND); return $composite; } } $hydrator = new ClassMethodsHydrator(false); $extractedArray = $hydrator-&gt;extract(new Foo()); $extractedArray will only have 'foo' =&gt; 'foo'; all other values are excluded from extraction. Note All pre-registered filters from the ClassMethodsHydrator hydrator are ignored when this interface is used. More on those methods below. Filter-enabled hydrators and the composite filter Hydrators can indicate they are filter-enabled by implementing Laminas\\Hydrator\\Filter\\FilterEnabledInterface : namespace Laminas\\Hydrator\\Filter; interface FilterEnabledInterface extends FilterProviderInterface { /** * Add a new filter to take care of what needs to be hydrated. * To exclude e.g. the method getServiceLocator: * * &lt;code&gt; * $composite-&gt;addFilter( * \"servicelocator\", * function ($property) { * [$class, $method] = explode('::', $property, 2); * return $method !== 'getServiceLocator'; * }, * FilterComposite::CONDITION_AND * ); * &lt;/code&gt; * * @param string $name Index in the composite * @param callable|FilterInterface $filter */ public function addFilter(string $name, $filter, int $condition = FilterComposite::CONDITION_OR) : void; /** * Check whether a specific filter exists at key $name or not * * @param string $name Index in the composite */ public function hasFilter(string $name) : bool; /** * Remove a filter from the composition. * * To not extract \"has\" methods, you simply need to unregister it * * &lt;code&gt; * $filterComposite-&gt;removeFilter('has'); * &lt;/code&gt; */ public function removeFilter(string $name) : void; } Note that the interface extends FilterProviderInterface , which means it also includes the getFilter() method. The FilterEnabledInterface makes the assumption that the class will be backed by a Laminas\\Hydrator\\Filter\\FilterComposite ; the various addFilter() , hasFilter() , and removeFilter() methods are expected to proxy to a FilterComposite instance. AbstractHydrator , on which all the hydrators shipped in this package are built, implements FilterEnabledInterface . Of the hydrators shipped, only one, ClassMethodsHydrator , defines any filters from the outset. Its constructor includes the following: $this-&gt;filterComposite-&gt;addFilter('is', new IsFilter()); $this-&gt;filterComposite-&gt;addFilter('has', new HasFilter()); $this-&gt;filterComposite-&gt;addFilter('get', new GetFilter()); $this-&gt;filterComposite-&gt;addFilter( 'parameter', new NumberOfParameterFilter(), FilterComposite::CONDITION_AND ); Remove filters If you want to tell a filter-enabled hydrator such as ClassMethodsHydrator not to extract methods that start with is , remove the related filter: $hydrator = new ClassMethodsHydrator(false); $hydrator-&gt;removeFilter('is'); After performing the above, the key/value pairs for is methods will no longer end up in your extracted array. Add filters You can add filters using the addFilter() method. Filters can either implement FilterInterface , or simply be PHP callables: $hydrator-&gt;addFilter('len', function($property) { return strlen($property) === 3; }); By default, every filter you add will be added with a conditional OR . If you want to add it with AND (such as the ClassMethodsHydrator does with its composed NumberOfParameterFilter , demonstrated above) provide the conditon as the third argument to addFilter : $hydrator-&gt;addFilter('len', function($property) { return strlen($property) === 3; }, FilterComposite::CONDITION_AND); One common use case for filters is to omit getters for values that you do not want to represent, such as a service manager instance: $hydrator-&gt;addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); The example above will exclude the getServiceManager() method and the servicemanager key from extraction, even if the get filter wants to add it.","title":"Filters"},{"location":"v3/filter/#laminashydratorfilter","text":"Hydrator filters allow you to manipulate the behavior of the extract() operation. This is especially useful, if you want to omit some internals (e.g. getServiceManager() ) from the array representation. It comes with a helpful Composite implementation, and several filters for common use cases. The filters are composed in the AbstractHydrator , so you can start using them immediately in any custom extensions you write that extend that class. namespace Laminas\\Hydrator\\Filter; interface FilterInterface { /** * Should return true, if the given filter does not match. */ public function filter(string $property) : bool; } If it returns true, the key/value pairs will be in the extracted arrays - if it returns false, you'll not see them again.","title":"Laminas\\Hydrator\\Filter"},{"location":"v3/filter/#filter-implementations","text":"","title":"Filter implementations"},{"location":"v3/filter/#use-filtercomposite-for-complex-filters","text":"FilterComposite implements FilterInterface as well, so you can add it as a regular filter to the hydrator. One benefit of this implementation is that you can add the filters with a condition and accomplish complex requirements using different filters with different conditions. You can pass the following conditions to the 3rd parameter, when you add a filter:","title":"Use FilterComposite for complex filters"},{"location":"v3/filter/#using-the-provider-interface","text":"Laminas\\Hydrator\\Filter\\FilterProviderInterface allows you to configure the behavior of the hydrator inside your objects. namespace Laminas\\Hydrator\\Filter; interface FilterProviderInterface { /** * Provides a filter for hydration * * @return FilterInterface */ public function getFilter(); } (The getFilter() method is automatically excluded from extract() .) If the extracted object implements the Laminas\\Hydrator\\Filter\\FilterProviderInterface , the returned FilterInterface instance can also be a FilterComposite . For example: Class Foo implements FilterProviderInterface { public function getFoo() { return 'foo'; } public function hasFoo() { return true; } public function getServiceManager() { return 'servicemanager'; } public function getEventManager() { return 'eventmanager'; } public function getFilter() { $composite = new FilterComposite(); $composite-&gt;addFilter('get', new GetFilter()); $exclusionComposite = new FilterComposite(); $exclusionComposite-&gt;addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $exclusionComposite-&gt;addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $composite-&gt;addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND); return $composite; } } $hydrator = new ClassMethodsHydrator(false); $extractedArray = $hydrator-&gt;extract(new Foo()); $extractedArray will only have 'foo' =&gt; 'foo'; all other values are excluded from extraction.","title":"Using the provider interface"},{"location":"v3/filter/#filter-enabled-hydrators-and-the-composite-filter","text":"Hydrators can indicate they are filter-enabled by implementing Laminas\\Hydrator\\Filter\\FilterEnabledInterface : namespace Laminas\\Hydrator\\Filter; interface FilterEnabledInterface extends FilterProviderInterface { /** * Add a new filter to take care of what needs to be hydrated. * To exclude e.g. the method getServiceLocator: * * &lt;code&gt; * $composite-&gt;addFilter( * \"servicelocator\", * function ($property) { * [$class, $method] = explode('::', $property, 2); * return $method !== 'getServiceLocator'; * }, * FilterComposite::CONDITION_AND * ); * &lt;/code&gt; * * @param string $name Index in the composite * @param callable|FilterInterface $filter */ public function addFilter(string $name, $filter, int $condition = FilterComposite::CONDITION_OR) : void; /** * Check whether a specific filter exists at key $name or not * * @param string $name Index in the composite */ public function hasFilter(string $name) : bool; /** * Remove a filter from the composition. * * To not extract \"has\" methods, you simply need to unregister it * * &lt;code&gt; * $filterComposite-&gt;removeFilter('has'); * &lt;/code&gt; */ public function removeFilter(string $name) : void; } Note that the interface extends FilterProviderInterface , which means it also includes the getFilter() method. The FilterEnabledInterface makes the assumption that the class will be backed by a Laminas\\Hydrator\\Filter\\FilterComposite ; the various addFilter() , hasFilter() , and removeFilter() methods are expected to proxy to a FilterComposite instance. AbstractHydrator , on which all the hydrators shipped in this package are built, implements FilterEnabledInterface . Of the hydrators shipped, only one, ClassMethodsHydrator , defines any filters from the outset. Its constructor includes the following: $this-&gt;filterComposite-&gt;addFilter('is', new IsFilter()); $this-&gt;filterComposite-&gt;addFilter('has', new HasFilter()); $this-&gt;filterComposite-&gt;addFilter('get', new GetFilter()); $this-&gt;filterComposite-&gt;addFilter( 'parameter', new NumberOfParameterFilter(), FilterComposite::CONDITION_AND );","title":"Filter-enabled hydrators and the composite filter"},{"location":"v3/migration/","text":"Migration from version 2 This document details changes made between version 2 and version 3 that could affect end-users. Minimum supported versions PHP Version 3 bumps the minimum supported PHP version to version 7.2. We chose this version in particular as it provides the object typehint, which allows us to enforce at the engine level what we were previously enforcing only at the documentation level. Additionally, we have enabled strict types in all class files shipped with this component. laminas-eventmanager The minimum supported version of laminas-eventmanager (used by the AggregateHydrator )is now 3.2.1. laminas-serializer The minimum supported version of laminas-serializer (used by the SerializableStrategy ) is now 2.9.0. laminas-servicemanager The minimum supported version of laminas-servicemanager (used by the HydratorPluginManager ) is now 3.3.2. Renamed interfaces The following interfaces were renamed: Laminas\\Hydrator\\FilterEnabledInterface becomes Laminas\\Hydrator\\Filter\\FilterEnabledInterface . Laminas\\Hydrator\\NamingStrategyEnabledInterface becomes Laminas\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface . Laminas\\Hydrator\\StrategyEnabledInterface becomes Laminas\\Hydrator\\Strategy\\StrategyEnabledInterface . Renamed classes The following classes were renamed: Laminas\\Hydrator\\ArraySerializable becomes Laminas\\Hydrator\\ArraySerializableHydrator Laminas\\Hydrator\\ClassMethods becomes Laminas\\Hydrator\\ClassMethodsHydrator Laminas\\Hydrator\\ObjectProperty becomes Laminas\\Hydrator\\ObjectPropertyHydrator Laminas\\Hydrator\\Reflection becomes Laminas\\Hydrator\\ReflectionHydrator In each case, a class named after the original has been created as a deprecated extension of the new class. This means you can continue to use the old class names, but only until version 4, at which point they will be removed. Additionally, aliases for the old class names have been added to the HydratorPluginManager , pointing to services named after the new class names. Interface changes Each of the interfaces provided by this package have been updated to add typehints where they were previously omitted (due to engine limitations), both on parameters and return values. These include: Laminas\\Hydrator\\ExtractionInterface : extract($object) becomes extract(object $object) : array Laminas\\Hydrator\\Filter\\FilterEnabledInterface (was Laminas\\Hydrator\\FilterEnabledInterface ): addFilter($name, $filter, $condition = Laminas\\Hydrator\\Filter\\FilterComposite::CONDITION_OR) becomes addFilter(string $name, $filter, int $condition = Laminas\\Hydrator\\Filter\\FilterComposite::CONDITION_OR) : void hasFilter($name) becomes hasFilter(string $name) : bool removeFilter($name) becomes removeFilter(string $name) : void Laminas\\Hydrator\\HydrationInterface : hydrate(array $data, $object) becomes hydrate(array $data, object $object) Laminas\\Hydrator\\HydratorAwareInterface : setHydrator(Laminas\\Hydrator\\HydratorInterface $hydrator) becomes setHydrator(Laminas\\Hydrator\\HydratorInterface $hydrator) : void getHydrator() becomes getHydrator() : ?Laminas\\Hydrator\\HydratorInterface Laminas\\Hydrator\\HydratorAwareTrait was updated to follow the interface; if you use the trait to implement the interface, no changes will be necessary. Laminas\\Hydrator\\HydratorOptionsInterface : setOptions($options) becomes setOptions(iterable $options) : void Laminas\\Hydrator\\HydratorProviderInterface : getHydratorConfig() becomes getHydratorConfig() : array Laminas\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface (was Laminas\\Hydrator\\NamingStrategyEnabledInterface ): setNamingStrategy(Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface $strategy) becomes setNamingStrategy(Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface $strategy) : void getNamingStrategy() becomes getNamingStrategy() : Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface removeNamingStrategy() becomes removeNamingStrategy() : void Laminas\\Hydrator\\Strategy\\StrategyEnabledInterface (was Laminas\\Hydrator\\StrategyEnabledInterface ): addStrategy($name, Laminas\\Hydrator\\Strategy\\StrategyInterface $strategy) becomes addStrategy(string $name, Laminas\\Hydrator\\Strategy\\StrategyInterface $strategy) : void getStrategy($name) becomes getStrategy(string $name) : Laminas\\Hydrator\\Strategy\\StrategyInterface hasStrategy($name) becomes hasStrategy(string $name) : bool removeStrategy($name) becomes removeStrategy(string $name) : void Laminas\\Hydrator\\Filter\\FilterInterface : filter($property) becomes filter(string $property) : bool Laminas\\Hydrator\\Filter\\FilterProviderInterface : getFilter() becomes getFilter() : Laminas\\Hydrator\\Filter\\FilterInterface Laminas\\Hydrator\\Iterator\\HydratingIteratorInterface : setPrototype($prototype) becomes setPrototype($prototype) : void ( $prototype continues to allow either a string or object) setHydrator(Laminas\\Hydrator\\HydratorInterface $hydrator) becomes setHydrator(Laminas\\Hydrator\\HydratorInterface $hydrator) : void Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface : extract($name) becomes extract(string $name, ?object $object = null) : string hydrate($name) becomes hydrate(string $name, ?array $data = null) : string Laminas\\Hydrator\\Strategy\\StrategyInterface : hydrate($value) becomes hydrate($value, ?array $data = null) (the $value parameter and return value can be any PHP type) extract($value) becomes extract($value, ?object $object = null) (the $value parameter and return value can be any PHP type) All implementations of these interface shipped in the component have been updated to ensure signatures match. If you are providing custom implementations, or extending the implementations provided in this package, you may need to update signatures per the above. Typehints As noted in the above section, typehints were added to all interfaces. In addition to those changes, the following methods were also updated to add typehints: Laminas\\Hydrator\\Aggregate\\AggregateHydrator : add(Laminas\\Hydrator\\HydratorInterface $hydrator, $priority = self::DEFAULT_PRIORITY) becomes add(Laminas\\Hydrator\\HydratorInterface $hydrator, int $priority = self::DEFAULT_PRIORITY) : void Laminas\\Hydrator\\Aggregate\\ExtractEvent : __construct($target, $extractionObject) becomes __construct(object $target, object $extractionObject) getExtractionObject() becomes getExtractionObject() : object setExtractionObject($extractionObject) becomes setExtractionObject(object $extractionObject) : void getExtractedData() becomes getExtractedData() : array setExtractedData(array $extractedData) becomes setExtractedData(array $extractedData) : void mergeExtractedData(array $additionalData) becomes mergeExtractedData(array $additionalData) : void Laminas\\Hydrator\\Aggregate\\HydrateEvent : __construct($target, $hydratedObject, array $hydrationData) becomes __construct(object $target, object $hydratedObject, array $hydrationData) getHydratedObject() becomes getHydratedObject() : object setHydratedObject($hydratedObject) becomes setHydratedObject(object $hydratedObject) : void getHydrationData() becomes getHydrationData() : array setHydrationData(array $hydrationData) becomes setHydrationData(array $hydrationData) : void Laminas\\Hydrator\\Aggregate\\HydratorListener : onHydrate(HydrateEvent $event) becomes onHydrate(HydrateEvent $event) : object onExtract(ExtractEvent $event) becomes onExtract(ExtractEvent $event) : array Laminas\\Hydrator\\ClassMethodsHydrator (was Laminas\\Hydrator\\ClassMethods ): __construct($underscoreSeparatedKeys = true, $methodExistsCheck = false) becomes __construct(bool $underscoreSeparatedKeys = true, bool $methodExistsCheck = false) setUnderscoreSeparatedKeys($underscoreSeparatedKeys) becomes setUnderscoreSeparatedKeys(bool $underscoreSeparatedKeys) : void getUnderscoreSeparatedKeys() becomes getUnderscoreSeparatedKeys() : bool setMethodExistsCheck($methodExistsCheck) becomes setMethodExistsCheck(bool $methodExistsCheck) : void getMethodExistsCheck() becomes getMethodExistsCheck() : bool Laminas\\Hydrator\\ConfigProvider : __invoke() becomes __invoke() : array getDependencyConfig() becomes getDependencyConfig() : array Laminas\\Hydrator\\DelegatingHydratorFactory : no longer implements Laminas\\ServiceManager\\FactoryInterface __invoke(Interop\\Container\\ContainerInterface $container, $requestedName, array $options = null) becomes __invoke(Psr\\Container\\ContainerInterface $container) : Laminas\\Hydrator\\DelegatingHydrator Laminas\\Hydrator\\Filter\\FilterComposite : __construct($orFilters = [], $andFilters = []) becomes __construct(array $orFilters = [], array $andFilters = []) Laminas\\Hydrator\\Filter\\MethodMatchFilter : __construct($method, $exclude = true) becomes __construct(string $method, bool $exclude = true) Laminas\\Hydrator\\Filter\\NumberOfParameterFilter : __construct($numberOfParameters = 0) becomes __construct(int $numberOfParameters = 0) Laminas\\Hydrator\\HydratorPluginManagerFactory : no longer implements Laminas\\ServiceManager\\FactoryInterface __invoke(Interop\\Container\\ContainerInterface $container, $requestedName, array $options = null) becomes __invoke(Psr\\Container\\ContainerInterface $container, string $name, ?array $options = []) : Laminas\\Hydrator\\HydratorPluginManager Laminas\\Hydrator\\Module : getConfig() becomes getConfig() : array init($moduleManager) becomes init(Laminas\\ModuleManager\\ModuleManager $moduleManager) : void Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy : __construct(array $strategies, Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface $defaultNamingStrategy = null) becomes __construct(array $strategies, ?Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface $defaultNamingStrategy = null) Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\\CamelCaseToUnderscoreFilter : filter($value) becomes filter(string $value) : string Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\\UnderscoreToCamelCaseFilter : filter($value) becomes filter(string $value) : string Laminas\\Hydrator\\Strategy\\ClosureStrategy : __construct($extractFunc = null, $hydrateFunc = null) becomes __construct(?callable $extractFunc = null, ?callable $hydrateFunc = null) Laminas\\Hydrator\\Strategy\\CollectionStrategy : __construct(Laminas\\Hydrator\\HydratorInterface $objectHydrator, $objectClassName) becomes __construct(Laminas\\Hydrator\\HydratorInterface $objectHydrator, string $objectClassName) Laminas\\Hydrator\\Strategy\\DateTimeFormatterStrategy : __construct($format = DateTime::RFC3339, DateTimeZone $timezone = null, $dateTimeFallback = false) becomes __construct(string $format = DateTime::RFC3339, ?DateTimeZone $timezone = null, bool $dateTimeFallback = false) Laminas\\Hydrator\\Strategy\\ExplodeStrategy : __construct($delimiter = ',', $explodeLimit = null) becomes __construct(string $delimiter = ',', ?int $explodeLimit = null) Laminas\\Hydrator\\Strategy\\SerializableStrategy : __construct($serializer, $serializerOptions = null) becomes __construct($serializer, ?iterable $serializerOptions = null) setSerializer($serializer) becomes setSerializer($serializer) : void getSerializer() becomes getSerializer($serializer) : Laminas\\Serializer\\Adapter\\AdapterInterface setSerializerOptions($serializerOptions) becomes setSerializerOptions(iterable $serializerOptions) : void getSerializerOptions() becomes getSerializerOptions() : array Laminas\\Hydrator\\Strategy\\StrategyChain : __construct($extractionStrategies) becomes __construct(iterable $extractionStrategies) ArrayMapNamingStrategy and MapNamingStrategy merged ArrayMapNamingStrategy and MapNamingStrategy were performing essentially the same duties, but in reverse. As such, for version 3, we have merged the two into MapNamingStrategy . To accommodate the three different use cases, we provide three \"named constructors\": public static function createFromExtractionMap(array $extractionMap) : MapNamingStrategy; public static function createFromHydrationMap(array $hydrationMap) : MapNamingStrategy; public static function createFromAsymmetricMap(array $extractionMap, array $hydrationMap) : MapNamingStrategy; In the first two cases, the constructor will flip the arrays for purposes of the opposite interaction; e.g., using createFromExtractionMap() will create a hydration map based on an array_flip() of the extraction map provided. You MUST use one of these methods to create an instance, as the constructor is now marked private . HydratorPluginManager This version removes support for laminas-servicemanager v2 service names. Under laminas-servicemanager v2, most special characters were removed, and the name normalized to all lowercase. Now, only fully qualified class names are mapped to factories, and short names (names omitting the namespace and/or \"Hydrator\" suffix) are mapped as aliases. Additionally, version 3 ships a standalone, PSR-11 compliant version, Laminas\\Hydrator\\StandaloneHydratorPluginManager . By default, the HydratorManager service alias will point to the StandaloneHydratorPluginManager if laminas-servicemanager is not installed, and the HydratorPluginManager otherwise. See the plugin managers chapter for more details.","title":"Migration"},{"location":"v3/migration/#migration-from-version-2","text":"This document details changes made between version 2 and version 3 that could affect end-users.","title":"Migration from version 2"},{"location":"v3/migration/#minimum-supported-versions","text":"","title":"Minimum supported versions"},{"location":"v3/migration/#renamed-interfaces","text":"The following interfaces were renamed: Laminas\\Hydrator\\FilterEnabledInterface becomes Laminas\\Hydrator\\Filter\\FilterEnabledInterface . Laminas\\Hydrator\\NamingStrategyEnabledInterface becomes Laminas\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface . Laminas\\Hydrator\\StrategyEnabledInterface becomes Laminas\\Hydrator\\Strategy\\StrategyEnabledInterface .","title":"Renamed interfaces"},{"location":"v3/migration/#renamed-classes","text":"The following classes were renamed: Laminas\\Hydrator\\ArraySerializable becomes Laminas\\Hydrator\\ArraySerializableHydrator Laminas\\Hydrator\\ClassMethods becomes Laminas\\Hydrator\\ClassMethodsHydrator Laminas\\Hydrator\\ObjectProperty becomes Laminas\\Hydrator\\ObjectPropertyHydrator Laminas\\Hydrator\\Reflection becomes Laminas\\Hydrator\\ReflectionHydrator In each case, a class named after the original has been created as a deprecated extension of the new class. This means you can continue to use the old class names, but only until version 4, at which point they will be removed. Additionally, aliases for the old class names have been added to the HydratorPluginManager , pointing to services named after the new class names.","title":"Renamed classes"},{"location":"v3/migration/#interface-changes","text":"Each of the interfaces provided by this package have been updated to add typehints where they were previously omitted (due to engine limitations), both on parameters and return values. These include: Laminas\\Hydrator\\ExtractionInterface : extract($object) becomes extract(object $object) : array Laminas\\Hydrator\\Filter\\FilterEnabledInterface (was Laminas\\Hydrator\\FilterEnabledInterface ): addFilter($name, $filter, $condition = Laminas\\Hydrator\\Filter\\FilterComposite::CONDITION_OR) becomes addFilter(string $name, $filter, int $condition = Laminas\\Hydrator\\Filter\\FilterComposite::CONDITION_OR) : void hasFilter($name) becomes hasFilter(string $name) : bool removeFilter($name) becomes removeFilter(string $name) : void Laminas\\Hydrator\\HydrationInterface : hydrate(array $data, $object) becomes hydrate(array $data, object $object) Laminas\\Hydrator\\HydratorAwareInterface : setHydrator(Laminas\\Hydrator\\HydratorInterface $hydrator) becomes setHydrator(Laminas\\Hydrator\\HydratorInterface $hydrator) : void getHydrator() becomes getHydrator() : ?Laminas\\Hydrator\\HydratorInterface Laminas\\Hydrator\\HydratorAwareTrait was updated to follow the interface; if you use the trait to implement the interface, no changes will be necessary. Laminas\\Hydrator\\HydratorOptionsInterface : setOptions($options) becomes setOptions(iterable $options) : void Laminas\\Hydrator\\HydratorProviderInterface : getHydratorConfig() becomes getHydratorConfig() : array Laminas\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface (was Laminas\\Hydrator\\NamingStrategyEnabledInterface ): setNamingStrategy(Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface $strategy) becomes setNamingStrategy(Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface $strategy) : void getNamingStrategy() becomes getNamingStrategy() : Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface removeNamingStrategy() becomes removeNamingStrategy() : void Laminas\\Hydrator\\Strategy\\StrategyEnabledInterface (was Laminas\\Hydrator\\StrategyEnabledInterface ): addStrategy($name, Laminas\\Hydrator\\Strategy\\StrategyInterface $strategy) becomes addStrategy(string $name, Laminas\\Hydrator\\Strategy\\StrategyInterface $strategy) : void getStrategy($name) becomes getStrategy(string $name) : Laminas\\Hydrator\\Strategy\\StrategyInterface hasStrategy($name) becomes hasStrategy(string $name) : bool removeStrategy($name) becomes removeStrategy(string $name) : void Laminas\\Hydrator\\Filter\\FilterInterface : filter($property) becomes filter(string $property) : bool Laminas\\Hydrator\\Filter\\FilterProviderInterface : getFilter() becomes getFilter() : Laminas\\Hydrator\\Filter\\FilterInterface Laminas\\Hydrator\\Iterator\\HydratingIteratorInterface : setPrototype($prototype) becomes setPrototype($prototype) : void ( $prototype continues to allow either a string or object) setHydrator(Laminas\\Hydrator\\HydratorInterface $hydrator) becomes setHydrator(Laminas\\Hydrator\\HydratorInterface $hydrator) : void Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface : extract($name) becomes extract(string $name, ?object $object = null) : string hydrate($name) becomes hydrate(string $name, ?array $data = null) : string Laminas\\Hydrator\\Strategy\\StrategyInterface : hydrate($value) becomes hydrate($value, ?array $data = null) (the $value parameter and return value can be any PHP type) extract($value) becomes extract($value, ?object $object = null) (the $value parameter and return value can be any PHP type) All implementations of these interface shipped in the component have been updated to ensure signatures match. If you are providing custom implementations, or extending the implementations provided in this package, you may need to update signatures per the above.","title":"Interface changes"},{"location":"v3/migration/#typehints","text":"As noted in the above section, typehints were added to all interfaces. In addition to those changes, the following methods were also updated to add typehints: Laminas\\Hydrator\\Aggregate\\AggregateHydrator : add(Laminas\\Hydrator\\HydratorInterface $hydrator, $priority = self::DEFAULT_PRIORITY) becomes add(Laminas\\Hydrator\\HydratorInterface $hydrator, int $priority = self::DEFAULT_PRIORITY) : void Laminas\\Hydrator\\Aggregate\\ExtractEvent : __construct($target, $extractionObject) becomes __construct(object $target, object $extractionObject) getExtractionObject() becomes getExtractionObject() : object setExtractionObject($extractionObject) becomes setExtractionObject(object $extractionObject) : void getExtractedData() becomes getExtractedData() : array setExtractedData(array $extractedData) becomes setExtractedData(array $extractedData) : void mergeExtractedData(array $additionalData) becomes mergeExtractedData(array $additionalData) : void Laminas\\Hydrator\\Aggregate\\HydrateEvent : __construct($target, $hydratedObject, array $hydrationData) becomes __construct(object $target, object $hydratedObject, array $hydrationData) getHydratedObject() becomes getHydratedObject() : object setHydratedObject($hydratedObject) becomes setHydratedObject(object $hydratedObject) : void getHydrationData() becomes getHydrationData() : array setHydrationData(array $hydrationData) becomes setHydrationData(array $hydrationData) : void Laminas\\Hydrator\\Aggregate\\HydratorListener : onHydrate(HydrateEvent $event) becomes onHydrate(HydrateEvent $event) : object onExtract(ExtractEvent $event) becomes onExtract(ExtractEvent $event) : array Laminas\\Hydrator\\ClassMethodsHydrator (was Laminas\\Hydrator\\ClassMethods ): __construct($underscoreSeparatedKeys = true, $methodExistsCheck = false) becomes __construct(bool $underscoreSeparatedKeys = true, bool $methodExistsCheck = false) setUnderscoreSeparatedKeys($underscoreSeparatedKeys) becomes setUnderscoreSeparatedKeys(bool $underscoreSeparatedKeys) : void getUnderscoreSeparatedKeys() becomes getUnderscoreSeparatedKeys() : bool setMethodExistsCheck($methodExistsCheck) becomes setMethodExistsCheck(bool $methodExistsCheck) : void getMethodExistsCheck() becomes getMethodExistsCheck() : bool Laminas\\Hydrator\\ConfigProvider : __invoke() becomes __invoke() : array getDependencyConfig() becomes getDependencyConfig() : array Laminas\\Hydrator\\DelegatingHydratorFactory : no longer implements Laminas\\ServiceManager\\FactoryInterface __invoke(Interop\\Container\\ContainerInterface $container, $requestedName, array $options = null) becomes __invoke(Psr\\Container\\ContainerInterface $container) : Laminas\\Hydrator\\DelegatingHydrator Laminas\\Hydrator\\Filter\\FilterComposite : __construct($orFilters = [], $andFilters = []) becomes __construct(array $orFilters = [], array $andFilters = []) Laminas\\Hydrator\\Filter\\MethodMatchFilter : __construct($method, $exclude = true) becomes __construct(string $method, bool $exclude = true) Laminas\\Hydrator\\Filter\\NumberOfParameterFilter : __construct($numberOfParameters = 0) becomes __construct(int $numberOfParameters = 0) Laminas\\Hydrator\\HydratorPluginManagerFactory : no longer implements Laminas\\ServiceManager\\FactoryInterface __invoke(Interop\\Container\\ContainerInterface $container, $requestedName, array $options = null) becomes __invoke(Psr\\Container\\ContainerInterface $container, string $name, ?array $options = []) : Laminas\\Hydrator\\HydratorPluginManager Laminas\\Hydrator\\Module : getConfig() becomes getConfig() : array init($moduleManager) becomes init(Laminas\\ModuleManager\\ModuleManager $moduleManager) : void Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy : __construct(array $strategies, Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface $defaultNamingStrategy = null) becomes __construct(array $strategies, ?Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface $defaultNamingStrategy = null) Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\\CamelCaseToUnderscoreFilter : filter($value) becomes filter(string $value) : string Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\\UnderscoreToCamelCaseFilter : filter($value) becomes filter(string $value) : string Laminas\\Hydrator\\Strategy\\ClosureStrategy : __construct($extractFunc = null, $hydrateFunc = null) becomes __construct(?callable $extractFunc = null, ?callable $hydrateFunc = null) Laminas\\Hydrator\\Strategy\\CollectionStrategy : __construct(Laminas\\Hydrator\\HydratorInterface $objectHydrator, $objectClassName) becomes __construct(Laminas\\Hydrator\\HydratorInterface $objectHydrator, string $objectClassName) Laminas\\Hydrator\\Strategy\\DateTimeFormatterStrategy : __construct($format = DateTime::RFC3339, DateTimeZone $timezone = null, $dateTimeFallback = false) becomes __construct(string $format = DateTime::RFC3339, ?DateTimeZone $timezone = null, bool $dateTimeFallback = false) Laminas\\Hydrator\\Strategy\\ExplodeStrategy : __construct($delimiter = ',', $explodeLimit = null) becomes __construct(string $delimiter = ',', ?int $explodeLimit = null) Laminas\\Hydrator\\Strategy\\SerializableStrategy : __construct($serializer, $serializerOptions = null) becomes __construct($serializer, ?iterable $serializerOptions = null) setSerializer($serializer) becomes setSerializer($serializer) : void getSerializer() becomes getSerializer($serializer) : Laminas\\Serializer\\Adapter\\AdapterInterface setSerializerOptions($serializerOptions) becomes setSerializerOptions(iterable $serializerOptions) : void getSerializerOptions() becomes getSerializerOptions() : array Laminas\\Hydrator\\Strategy\\StrategyChain : __construct($extractionStrategies) becomes __construct(iterable $extractionStrategies)","title":"Typehints"},{"location":"v3/migration/#arraymapnamingstrategy-and-mapnamingstrategy-merged","text":"ArrayMapNamingStrategy and MapNamingStrategy were performing essentially the same duties, but in reverse. As such, for version 3, we have merged the two into MapNamingStrategy . To accommodate the three different use cases, we provide three \"named constructors\": public static function createFromExtractionMap(array $extractionMap) : MapNamingStrategy; public static function createFromHydrationMap(array $hydrationMap) : MapNamingStrategy; public static function createFromAsymmetricMap(array $extractionMap, array $hydrationMap) : MapNamingStrategy; In the first two cases, the constructor will flip the arrays for purposes of the opposite interaction; e.g., using createFromExtractionMap() will create a hydration map based on an array_flip() of the extraction map provided. You MUST use one of these methods to create an instance, as the constructor is now marked private .","title":"ArrayMapNamingStrategy and MapNamingStrategy merged"},{"location":"v3/migration/#hydratorpluginmanager","text":"This version removes support for laminas-servicemanager v2 service names. Under laminas-servicemanager v2, most special characters were removed, and the name normalized to all lowercase. Now, only fully qualified class names are mapped to factories, and short names (names omitting the namespace and/or \"Hydrator\" suffix) are mapped as aliases. Additionally, version 3 ships a standalone, PSR-11 compliant version, Laminas\\Hydrator\\StandaloneHydratorPluginManager . By default, the HydratorManager service alias will point to the StandaloneHydratorPluginManager if laminas-servicemanager is not installed, and the HydratorPluginManager otherwise. See the plugin managers chapter for more details.","title":"HydratorPluginManager"},{"location":"v3/plugin-managers/","text":"Plugin Managers It can be useful to compose a plugin manager from which you can retrieve hydrators; in fact, Laminas\\Hydrator\\DelegatingHydrator does exactly that! With such a manager, you can retrieve instances using short names, or instances that have dependencies on other services, without needing to know the details of how that works. Examples of Hydrator plugin managers in real-world scenarios include: hydrating database result sets preparing API payloads HydratorPluginManagerInterface We provide two plugin manager implementations. Essentially, they only need to implement the PSR-11 ContainerInterface , but plugin managers in current versions of laminas-servicemanager only implement it indirectly via the container-interop project. As such, we ship Laminas\\Hydrator\\HydratorPluginManagerInterface , which simply extends the PSR-11 Psr\\Container\\ContainerInterface . Each of our implementations implement it. HydratorPluginManager If you have used laminas-hydrator prior to version 3, you are likely already familiar with this class, as it has been the implementation we have shipped from initial versions. The HydratorPluginManager extends the laminas-servicemanager AbstractPluginManager , and has the following behaviors: It will only return Laminas\\Hydrator\\HydratorInterface instances. It defines short-name aliases for all shipped hydrators (the class name minus the namespace), in a variety of casing combinations. All but the DelegatingHydrator are defined as invokable services (meaning they can be instantiated without any constructor arguments). The DelegatingHydrator is configured as a factory-based service, mapping to the Laminas\\Hydrator\\DelegatingHydratorFactory . No services are shared; a new instance is created each time you call get() . HydratorPluginManagerFactory Laminas\\Hydrator\\HydratorPluginManager is mapped to the factory Laminas\\Hydrator\\HydratorPluginManagerFactory when wired to the dependency injection container. The factory will look for the config service, and use the hydrators configuration key to seed it with additional services. This configuration key should map to an array that follows standard laminas-servicemanager configuration . StandaloneHydratorPluginManager Laminas\\Hydrator\\StandaloneHydratorPluginManager provides an implementation that has no dependencies on other libraries. It can only load the hydrators shipped with laminas-hydrator . StandardHydratorPluginManagerFactory Laminas\\Hydrator\\StandardHydratorPluginManager is mapped to the factory Laminas\\Hydrator\\StandardHydratorPluginManagerFactory when wired to the dependency injection container. HydratorManager alias Laminas\\Hydrator\\ConfigManager defines an alias service, HydratorManager . That service will point to Laminas\\Hydrator\\HydratorPluginManager if laminas-servicemanager is installed, and Laminas\\Hydrator\\StandaloneHydratorPluginManager otherwise. Custom plugin managers If you do not want to use laminas-servicemanager, but want a plugin manager that is customizable, or at least capable of loading the hydrators you have defined for your application, you should write a custom implementation of Laminas\\Hydrator\\HydratorPluginManagerInterface , and wire it to the HydratorManager service, and/or one of the existing service names. As an example, if you want a configurable solution that uses factories, and want those factories capable of pulling application-level dependencies, you might do something like the following: Create a custom plugin manager class, e.g. src/YourApplication/CustomHydratorPluginManager.php : namespace YourApplication; use Psr\\Container\\NotFoundExceptionInterface; use Psr\\Container\\ContainerInterface; use RuntimeException; use Laminas\\Hydrator\\HydratorInterface; use Laminas\\Hydrator\\HydratorPluginManagerInterface; use Laminas\\Hydrator\\StandaloneHydratorPluginManager; class CustomHydratorPluginManager implements HydratorPluginManagerInterface { /** @var ContainerInterface */ private $appContainer; /** @var StandaloneHydratorPluginManager */ private $defaults; /** @var array&lt;string, string|callable&gt; */ private $factories = []; public function __construct(ContainerInterface $appContainer) { $this-&gt;appContainer = $appContainer; $this-&gt;defaults = new StandaloneHydratorPluginManager(); } /** * {@inheritDoc} */ public function get($id) : HydratorInterface { if (! isset($this-&gt;factories[$id]) &amp;&amp; ! $this-&gt;defaults-&gt;has($id)) { $message = sprintf('Hydrator service %s not found', $id); throw new class($message) extends RuntimeException implements NotFoundExceptionInterface {}; } // Default was requested; fallback to standalone container if (! isset($this-&gt;factories[$id])) { return $this-&gt;defaults-&gt;get($id); } $factory = $this-&gt;factories[$id]; if (is_string($factory)) { $this-&gt;factories[$id] = $factory = new $factory(); } return $factory($this-&gt;appContainer, $id); } public function has($id) : bool { return isset($this-&gt;factories[$id]) || $this-&gt;defaults-&gt;has($id); } public function setFactoryClass(string $name, string $factory) : void { $this-&gt;factories[$name] = $factory; } public function setFactory(string $name, callable $factory) : void { $this-&gt;factories[$name] = $factory; } } Create a factory for the custom plugin manager, e.g. src/YourApplication/CustomHydratorPluginManagerFactory.php : namespace YourApplication; use Psr\\Container\\ContainerInterface; class CustomHydratorPluginManagerFactory { public function __invoke(ContainerInterface $container) : CustomHydratorPluginManager { $config = $container-&gt;has('config') ? $container-&gt;get('config') : []; $config = $config['hydrators']['factories'] ?? []; $manager = new CustomHydratorPluginManager($this); if ([] !== $config) { $this-&gt;configureManager($manager, $config); } return $manager; } /** * @param array&lt;string, string|callable&gt; $config */ private function configureManager(CustomHydratorPluginManager $manager, array $config) : void { foreach ($config as $name =&gt; $factory) { is_string($factory) ? $manager-&gt;setFactoryClass($name, $factory) : $manager-&gt;setFactory($name, $factory); } } } Register the custom plugin manager in the application configuration, e.g. config/autoload/hydrators.global.php : return [ 'dependencies' =&gt; [ 'aliases' =&gt; [ 'HydratorManager' =&gt; \\YourApplication\\CustomHydratorPluginManager::class, ], 'factories' =&gt; [ \\YourApplication\\CustomHydratorPluginManager::class =&gt; \\YourApplication\\CustomHydratorPluginManagerFactory::class ], ], 'hydrators' =&gt; [ 'factories' =&gt; [ \\Blog\\PostHydrator::class =&gt; \\Blog\\PostHydratorFactory::class, \\News\\ItemHydrator::class =&gt; \\News\\ItemHydratorFactory::class, // etc. ], ], ];","title":"Plugin Managers"},{"location":"v3/plugin-managers/#plugin-managers","text":"It can be useful to compose a plugin manager from which you can retrieve hydrators; in fact, Laminas\\Hydrator\\DelegatingHydrator does exactly that! With such a manager, you can retrieve instances using short names, or instances that have dependencies on other services, without needing to know the details of how that works. Examples of Hydrator plugin managers in real-world scenarios include: hydrating database result sets preparing API payloads","title":"Plugin Managers"},{"location":"v3/plugin-managers/#hydratorpluginmanagerinterface","text":"We provide two plugin manager implementations. Essentially, they only need to implement the PSR-11 ContainerInterface , but plugin managers in current versions of laminas-servicemanager only implement it indirectly via the container-interop project. As such, we ship Laminas\\Hydrator\\HydratorPluginManagerInterface , which simply extends the PSR-11 Psr\\Container\\ContainerInterface . Each of our implementations implement it.","title":"HydratorPluginManagerInterface"},{"location":"v3/plugin-managers/#hydratorpluginmanager","text":"If you have used laminas-hydrator prior to version 3, you are likely already familiar with this class, as it has been the implementation we have shipped from initial versions. The HydratorPluginManager extends the laminas-servicemanager AbstractPluginManager , and has the following behaviors: It will only return Laminas\\Hydrator\\HydratorInterface instances. It defines short-name aliases for all shipped hydrators (the class name minus the namespace), in a variety of casing combinations. All but the DelegatingHydrator are defined as invokable services (meaning they can be instantiated without any constructor arguments). The DelegatingHydrator is configured as a factory-based service, mapping to the Laminas\\Hydrator\\DelegatingHydratorFactory . No services are shared; a new instance is created each time you call get() .","title":"HydratorPluginManager"},{"location":"v3/plugin-managers/#standalonehydratorpluginmanager","text":"Laminas\\Hydrator\\StandaloneHydratorPluginManager provides an implementation that has no dependencies on other libraries. It can only load the hydrators shipped with laminas-hydrator .","title":"StandaloneHydratorPluginManager"},{"location":"v3/plugin-managers/#hydratormanager-alias","text":"Laminas\\Hydrator\\ConfigManager defines an alias service, HydratorManager . That service will point to Laminas\\Hydrator\\HydratorPluginManager if laminas-servicemanager is installed, and Laminas\\Hydrator\\StandaloneHydratorPluginManager otherwise.","title":"HydratorManager alias"},{"location":"v3/plugin-managers/#custom-plugin-managers","text":"If you do not want to use laminas-servicemanager, but want a plugin manager that is customizable, or at least capable of loading the hydrators you have defined for your application, you should write a custom implementation of Laminas\\Hydrator\\HydratorPluginManagerInterface , and wire it to the HydratorManager service, and/or one of the existing service names. As an example, if you want a configurable solution that uses factories, and want those factories capable of pulling application-level dependencies, you might do something like the following: Create a custom plugin manager class, e.g. src/YourApplication/CustomHydratorPluginManager.php : namespace YourApplication; use Psr\\Container\\NotFoundExceptionInterface; use Psr\\Container\\ContainerInterface; use RuntimeException; use Laminas\\Hydrator\\HydratorInterface; use Laminas\\Hydrator\\HydratorPluginManagerInterface; use Laminas\\Hydrator\\StandaloneHydratorPluginManager; class CustomHydratorPluginManager implements HydratorPluginManagerInterface { /** @var ContainerInterface */ private $appContainer; /** @var StandaloneHydratorPluginManager */ private $defaults; /** @var array&lt;string, string|callable&gt; */ private $factories = []; public function __construct(ContainerInterface $appContainer) { $this-&gt;appContainer = $appContainer; $this-&gt;defaults = new StandaloneHydratorPluginManager(); } /** * {@inheritDoc} */ public function get($id) : HydratorInterface { if (! isset($this-&gt;factories[$id]) &amp;&amp; ! $this-&gt;defaults-&gt;has($id)) { $message = sprintf('Hydrator service %s not found', $id); throw new class($message) extends RuntimeException implements NotFoundExceptionInterface {}; } // Default was requested; fallback to standalone container if (! isset($this-&gt;factories[$id])) { return $this-&gt;defaults-&gt;get($id); } $factory = $this-&gt;factories[$id]; if (is_string($factory)) { $this-&gt;factories[$id] = $factory = new $factory(); } return $factory($this-&gt;appContainer, $id); } public function has($id) : bool { return isset($this-&gt;factories[$id]) || $this-&gt;defaults-&gt;has($id); } public function setFactoryClass(string $name, string $factory) : void { $this-&gt;factories[$name] = $factory; } public function setFactory(string $name, callable $factory) : void { $this-&gt;factories[$name] = $factory; } } Create a factory for the custom plugin manager, e.g. src/YourApplication/CustomHydratorPluginManagerFactory.php : namespace YourApplication; use Psr\\Container\\ContainerInterface; class CustomHydratorPluginManagerFactory { public function __invoke(ContainerInterface $container) : CustomHydratorPluginManager { $config = $container-&gt;has('config') ? $container-&gt;get('config') : []; $config = $config['hydrators']['factories'] ?? []; $manager = new CustomHydratorPluginManager($this); if ([] !== $config) { $this-&gt;configureManager($manager, $config); } return $manager; } /** * @param array&lt;string, string|callable&gt; $config */ private function configureManager(CustomHydratorPluginManager $manager, array $config) : void { foreach ($config as $name =&gt; $factory) { is_string($factory) ? $manager-&gt;setFactoryClass($name, $factory) : $manager-&gt;setFactory($name, $factory); } } } Register the custom plugin manager in the application configuration, e.g. config/autoload/hydrators.global.php : return [ 'dependencies' =&gt; [ 'aliases' =&gt; [ 'HydratorManager' =&gt; \\YourApplication\\CustomHydratorPluginManager::class, ], 'factories' =&gt; [ \\YourApplication\\CustomHydratorPluginManager::class =&gt; \\YourApplication\\CustomHydratorPluginManagerFactory::class ], ], 'hydrators' =&gt; [ 'factories' =&gt; [ \\Blog\\PostHydrator::class =&gt; \\Blog\\PostHydratorFactory::class, \\News\\ItemHydrator::class =&gt; \\News\\ItemHydratorFactory::class, // etc. ], ], ];","title":"Custom plugin managers"},{"location":"v3/quick-start/","text":"Quick Start The laminas-hydrator component provides functionality for hydrating objects (which is the act of populating an object from a set of data) and extracting data from them. The component contains concrete implementations for a number of common use cases, such as by using arrays, object methods, and reflection, and provides interfaces for creating custom implementations. Basic Usage Hydrating an Object To hydrate an object with data, instantiate the hydrator and then pass to it the data for hydrating the object. $hydrator = new Laminas\\Hydrator\\ArraySerializableHydrator(); $data = [ 'first_name' =&gt; 'James', 'last_name' =&gt; 'Kahn', 'email_address' =&gt; 'james.kahn@example.org', 'phone_number' =&gt; '+61 419 1234 5678', ]; $object = $hydrator-&gt;hydrate($data, new ArrayObject()); Extracting Values From an Object To extract data from an object, instantiate the applicable hydrator and then call extract , passing to it the object to extract data from. $hydrator = new Laminas\\Hydrator\\ArraySerializableHydrator(); // ... Assuming that $object has already been initialised $data = $hydrator-&gt;extract($object); Available Implementations ArraySerializableHydrator The ArraySerializableHydrator hydrates data from an array and extracts an object’s data returning it as an array. Objects passed to the hydrate method must implement either exchangeArray() or populate() to support hydration, and must implement getArrayCopy() to support extraction. ClassMethodsHydrator The ClassMethodsHydrator calls \"setter\" methods matching keys in the data set to hydrate objects and calls \"getter\" methods matching keys in the data set during extraction, based on the following rules: is*() , has*() , and get*() methods will be used when extracting data. The method prefix will be removed from the key's name. set*() methods will be used when hydrating properties. class User { private $firstName; private $lastName; private $emailAddress; private $phoneNumber; public function setFirstName(string $firstName) { $this-&gt;firstName = $firstName; } public function setLastName(string $lastName) { $this-&gt;lastName = $lastName; } public function setEmailAddress(string $emailAddress) { $this-&gt;emailAddress = $emailAddress; } public function setPhoneNumber(string $phoneNumber) { $this-&gt;phoneNumber = $phoneNumber; } } $data = [ 'first_name' =&gt; 'James', 'last_name' =&gt; 'Kahn', 'email_address' =&gt; 'james.kahn@example.org', 'phone_number' =&gt; '+61 419 1234 5678', ]; $hydrator = new Laminas\\Hydrator\\ClassMethodsHydrator(); $user = $hydrator-&gt;hydrate($data, new User()); $data = $hydrator-&gt;extract(new User()); ObjectPropertyHydrator The ObjectPropertyHydrator hydrates objects and extracts data using publicly accessible properties which match a key in the data set. class User { public $firstName; public $lastName; public $emailAddress; public $phoneNumber; } $data = [ 'first_name' =&gt; 'James', 'last_name' =&gt; 'Kahn', 'email_address' =&gt; 'james.kahn@example.org', 'phone_number' =&gt; '+61 419 1234 5678', ]; $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $user = $hydrator-&gt;hydrate($data, new User()); $data = $hydrator-&gt;extract(new User()); ReflectionHydrator The ReflectionHydrator is similar to the ObjectPropertyHydrator , however it uses PHP's reflection API to hydrate or extract properties of any visibility. Any data key matching an existing property will be hydrated. Any existing properties will be used for extracting data. class User { private $firstName; private $lastName; private $emailAddress; private $phoneNumber; } $data = [ 'first_name' =&gt; 'James', 'last_name' =&gt; 'Kahn', 'email_address' =&gt; 'james.kahn@example.org', 'phone_number' =&gt; '+61 419 1234 5678', ]; $hydrator = new Laminas\\Hydrator\\ReflectionHydrator(); $user = $hydrator-&gt;hydrate($data, new User()); $data = $hydrator-&gt;extract(new User()); DelegatingHydrator The DelegatingHydrator composes a hydrator locator, and will delegate hydrate() and extract() calls to the appropriate one based upon the class name of the object being operated on. // Instantiate each hydrator you wish to delegate to $albumHydrator = new Laminas\\Hydrator\\ClassMethodsHydrator(); $artistHydrator = new Laminas\\Hydrator\\ClassMethodsHydrator(); // Map the entity class name to the hydrator using the HydratorPluginManager. // In this case we have two entity classes, \"Album\" and \"Artist\". $hydrators = new Laminas\\Hydrator\\HydratorPluginManager; $hydrators-&gt;setService('Album', $albumHydrator); $hydrators-&gt;setService('Artist', $artistHydrator); // Create the DelegatingHydrator and tell it to use our configured hydrator locator $delegating = new Laminas\\Hydrator\\DelegatingHydrator($hydrators); // Now we can use $delegating to hydrate or extract any supported object // Assumes that $data and Artist have already been initialised $array = $delegating-&gt;extract(new Artist()); $artist = $delegating-&gt;hydrate($data, new Artist());","title":"Quick Start"},{"location":"v3/quick-start/#quick-start","text":"The laminas-hydrator component provides functionality for hydrating objects (which is the act of populating an object from a set of data) and extracting data from them. The component contains concrete implementations for a number of common use cases, such as by using arrays, object methods, and reflection, and provides interfaces for creating custom implementations.","title":"Quick Start"},{"location":"v3/quick-start/#basic-usage","text":"","title":"Basic Usage"},{"location":"v3/quick-start/#available-implementations","text":"","title":"Available Implementations"},{"location":"v3/strategy/","text":"Introduction You can compose Laminas\\Hydrator\\Strategy\\StrategyInterface instances in any of the hydrators to manipulate the way they behave on extract() and hydrate() for specific key/value pairs. The interface offers the following definitions: namespace Laminas\\Hydrator\\Strategy; interface StrategyInterface { /** * Converts the given value so that it can be extracted by the hydrator. * * @param mixed $value The original value. * @param null|object $object (optional) The original object for context. * @return mixed Returns the value that should be extracted. */ public function extract($value, ?object $object = null); /** * Converts the given value so that it can be hydrated by the hydrator. * * @param mixed $value The original value. * @param null|array $data (optional) The original data for context. * @return mixed Returns the value that should be hydrated. */ public function hydrate($value, ?array $data = null); } This interface is similar to what the Laminas\\Hydrator\\ExtractionInterface and Laminas\\Hydrator\\HydrationInterface provide; the reason is that strategies provide a proxy implementation for hydrate() and extract() on individual values. For this reason, their return types are listed as mixed, versus as array and object , respectively. Adding strategies to the hydrators This package provides the interface Laminas\\Hydrator\\Strategy\\StrategyEnabledInterface . Hydrators can implement this interface, and then call on its getStrategy() method in order to extract or hydrate individual values. The interface has the following definition: namespace Laminas\\Hydrator\\Strategy; interface StrategyEnabledInterface { /** * Adds the given strategy under the given name. */ public function addStrategy(string $name, StrategyInterface $strategy) : void; /** * Gets the strategy with the given name. */ public function getStrategy(string $name) : StrategyInterface; /** * Checks if the strategy with the given name exists. */ public function hasStrategy(string $name) : bool; /** * Removes the strategy with the given name. */ public function removeStrategy(string $name) : void; } We provide a default implementation of the interface as part of Laminas\\Hydrator\\AbstractHydrator ; it uses an array property to store and retrieve strategies by name when extracting and hydrating values. Since all shipped hydrators are based on AbstractHydrator , they share these capabilities. Additionally, the functionality that consumes strategies within AbstractHydrator also contains checks if a naming strategy is composed, and, if present, will use it to translate the property name prior to looking up a strategy for it. Available implementations Laminas\\Hydrator\\Strategy\\BooleanStrategy This strategy converts values into Booleans and vice versa. It expects two arguments at the constructor, which are used to define value maps for true and false . Laminas\\Hydrator\\Strategy\\ClosureStrategy This is a strategy that allows you to pass in options for: hydrate , a callback to be called when hydrating a value, and extract , a callback to be called when extracting a value. Laminas\\Hydrator\\Strategy\\DateTimeFormatterStrategy DateTimeFormatterStrategy provides bidirectional conversion between strings and DateTime instances. The input and output formats can be provided as constructor arguments. The strategy allows DateTime formats that use ! to prepend the format, or | or + to append it; these ensure that, during hydration, the new DateTime instance created will set the time element accordingly. As a specific example, Y-m-d| will drop the time component, ensuring comparisons are based on a midnight time value. Starting in version 3.0, the constructor defines a third, optional argument, $dateTimeFallback . If enabled and hydration fails, the given string is parsed by the DateTime constructor, as demonstrated below: // Previous behavior: $strategy = new Laminas\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d H:i:s.uP'); $hydrated1 = $strategy-&gt;hydrate('2016-03-04 10:29:40.123456+01'); // Format is the same; returns DateTime instance $hydrated2 = $strategy-&gt;hydrate('2016-03-04 10:29:40+01'); // Format is different; value is not hydrated // Using new $dateTimeFallback flag; both values are hydrated: $strategy = new Laminas\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d H:i:s.uP', null, true); $hydrated1 = $strategy-&gt;hydrate('2016-03-04 10:29:40.123456+01'); $hydrated2 = $strategy-&gt;hydrate('2016-03-04 10:29:40+01'); Laminas\\Hydrator\\Strategy\\DefaultStrategy The DefaultStrategy simply proxies everything through, without performing any conversion of values. Laminas\\Hydrator\\Strategy\\ExplodeStrategy This strategy is a wrapper around PHP's implode() and explode() functions. The delimiter and a limit can be provided to the constructor; the limit will only be used for extract operations. Laminas\\Hydrator\\Strategy\\StrategyChain This strategy takes an array of StrategyInterface instances and iterates over them when performing extract() and hydrate() operations. Each operates on the return value of the previous, allowing complex operations based on smaller, single-purpose strategies. Writing custom strategies The following example, while not terribly useful, will provide you with the basics for writing your own strategies, as well as provide ideas as to where and when to use them. This strategy simply transforms the value for the defined key using str_rot13() during both the extract() and hydrate() operations: class Rot13Strategy implements StrategyInterface { public function extract($value) { return str_rot13($value); } public function hydrate($value) { return str_rot13($value); } } This is the example class with which we want to use the hydrator example: class Foo { protected $foo = null; protected $bar = null; public function getFoo() { return $this-&gt;foo; } public function setFoo($foo) { $this-&gt;foo = $foo; } public function getBar() { return $this-&gt;bar; } public function setBar($bar) { $this-&gt;bar = $bar; } } Now, we'll add the rot13 strategy to the method getFoo() and setFoo($foo) : $foo = new Foo(); $foo-&gt;setFoo('bar'); $foo-&gt;setBar('foo'); $hydrator = new ClassMethodsHydrator(); $hydrator-&gt;addStrategy('foo', new Rot13Strategy()); When you use the hydrator to extract an array for the object $foo , you'll receive the following: $extractedArray = $hydrator-&gt;extract($foo); // array(2) { // [\"foo\"]=&gt; // string(3) \"one\" // [\"bar\"]=&gt; // string(3) \"foo\" // } And when hydrating a new Foo instance: $hydrator-&gt;hydrate($extractedArray, $foo) // object(Foo)#2 (2) { // [\"foo\":protected]=&gt; // string(3) \"bar\" // [\"bar\":protected]=&gt; // string(3) \"foo\" // }","title":"Introduction"},{"location":"v3/strategy/#introduction","text":"You can compose Laminas\\Hydrator\\Strategy\\StrategyInterface instances in any of the hydrators to manipulate the way they behave on extract() and hydrate() for specific key/value pairs. The interface offers the following definitions: namespace Laminas\\Hydrator\\Strategy; interface StrategyInterface { /** * Converts the given value so that it can be extracted by the hydrator. * * @param mixed $value The original value. * @param null|object $object (optional) The original object for context. * @return mixed Returns the value that should be extracted. */ public function extract($value, ?object $object = null); /** * Converts the given value so that it can be hydrated by the hydrator. * * @param mixed $value The original value. * @param null|array $data (optional) The original data for context. * @return mixed Returns the value that should be hydrated. */ public function hydrate($value, ?array $data = null); } This interface is similar to what the Laminas\\Hydrator\\ExtractionInterface and Laminas\\Hydrator\\HydrationInterface provide; the reason is that strategies provide a proxy implementation for hydrate() and extract() on individual values. For this reason, their return types are listed as mixed, versus as array and object , respectively.","title":"Introduction"},{"location":"v3/strategy/#adding-strategies-to-the-hydrators","text":"This package provides the interface Laminas\\Hydrator\\Strategy\\StrategyEnabledInterface . Hydrators can implement this interface, and then call on its getStrategy() method in order to extract or hydrate individual values. The interface has the following definition: namespace Laminas\\Hydrator\\Strategy; interface StrategyEnabledInterface { /** * Adds the given strategy under the given name. */ public function addStrategy(string $name, StrategyInterface $strategy) : void; /** * Gets the strategy with the given name. */ public function getStrategy(string $name) : StrategyInterface; /** * Checks if the strategy with the given name exists. */ public function hasStrategy(string $name) : bool; /** * Removes the strategy with the given name. */ public function removeStrategy(string $name) : void; } We provide a default implementation of the interface as part of Laminas\\Hydrator\\AbstractHydrator ; it uses an array property to store and retrieve strategies by name when extracting and hydrating values. Since all shipped hydrators are based on AbstractHydrator , they share these capabilities. Additionally, the functionality that consumes strategies within AbstractHydrator also contains checks if a naming strategy is composed, and, if present, will use it to translate the property name prior to looking up a strategy for it.","title":"Adding strategies to the hydrators"},{"location":"v3/strategy/#available-implementations","text":"","title":"Available implementations"},{"location":"v3/strategy/#writing-custom-strategies","text":"The following example, while not terribly useful, will provide you with the basics for writing your own strategies, as well as provide ideas as to where and when to use them. This strategy simply transforms the value for the defined key using str_rot13() during both the extract() and hydrate() operations: class Rot13Strategy implements StrategyInterface { public function extract($value) { return str_rot13($value); } public function hydrate($value) { return str_rot13($value); } } This is the example class with which we want to use the hydrator example: class Foo { protected $foo = null; protected $bar = null; public function getFoo() { return $this-&gt;foo; } public function setFoo($foo) { $this-&gt;foo = $foo; } public function getBar() { return $this-&gt;bar; } public function setBar($bar) { $this-&gt;bar = $bar; } } Now, we'll add the rot13 strategy to the method getFoo() and setFoo($foo) : $foo = new Foo(); $foo-&gt;setFoo('bar'); $foo-&gt;setBar('foo'); $hydrator = new ClassMethodsHydrator(); $hydrator-&gt;addStrategy('foo', new Rot13Strategy()); When you use the hydrator to extract an array for the object $foo , you'll receive the following: $extractedArray = $hydrator-&gt;extract($foo); // array(2) { // [\"foo\"]=&gt; // string(3) \"one\" // [\"bar\"]=&gt; // string(3) \"foo\" // } And when hydrating a new Foo instance: $hydrator-&gt;hydrate($extractedArray, $foo) // object(Foo)#2 (2) { // [\"foo\":protected]=&gt; // string(3) \"bar\" // [\"bar\":protected]=&gt; // string(3) \"foo\" // }","title":"Writing custom strategies"},{"location":"v3/naming-strategy/composite-naming-strategy/","text":"CompositeNamingStrategy Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy allows you to specify which naming strategy should be used for each key encountered during hydration or extraction. Basic Usage When invoked, the following composite strategy will extract the property bar to the array key foo (using the MapNamingStrategy ), and the property barBat to the array key bar_bat (using the UnderscoreNamingStrategy ): class Foo { public $bar; public $barBat; } $mapStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' =&gt; 'bar' ]); $underscoreNamingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ 'bar' =&gt; $mapStrategy, 'barBat' =&gt; $underscoreNamingStrategy, ]); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $foo-&gt;bar = 123; $foo-&gt;barBat = 42; print_r($foo); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 [bar_bat] =&gt; 42 ) Unfortunately, the CompositeNamingStrategy can only be used for extraction as it will not know how to handle the keys necessary for hydration ( foo and bar_bat , respectively). To rectify this we have to cover the keys for both hydration and extraction in our composite strategy: class Foo { public $bar; public $barBat; } $mapStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' =&gt; 'bar' ]); $underscoreNamingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ // Define both directions for the foo =&gt; bar mapping 'bar' =&gt; $mapStrategy, 'foo' =&gt; $mapStrategy, // Define both directions for the barBat =&gt; bar_bat mapping 'barBat' =&gt; $underscoreNamingStrategy, 'bar_bat' =&gt; $underscoreNamingStrategy, ]); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $foo-&gt;bar = 123; $foo-&gt;barBat = 42; $array = $hydrator-&gt;extract($foo); print_r($foo); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 ) print_r($array); // Array ( [foo] =&gt; 123 [bar_bat] =&gt; 42 ) $foo2 = new Foo(); $hydrator-&gt;hydrate($array, $foo2); print_r($foo2); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 )","title":"Composite"},{"location":"v3/naming-strategy/composite-naming-strategy/#compositenamingstrategy","text":"Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy allows you to specify which naming strategy should be used for each key encountered during hydration or extraction.","title":"CompositeNamingStrategy"},{"location":"v3/naming-strategy/composite-naming-strategy/#basic-usage","text":"When invoked, the following composite strategy will extract the property bar to the array key foo (using the MapNamingStrategy ), and the property barBat to the array key bar_bat (using the UnderscoreNamingStrategy ): class Foo { public $bar; public $barBat; } $mapStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' =&gt; 'bar' ]); $underscoreNamingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ 'bar' =&gt; $mapStrategy, 'barBat' =&gt; $underscoreNamingStrategy, ]); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $foo-&gt;bar = 123; $foo-&gt;barBat = 42; print_r($foo); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 [bar_bat] =&gt; 42 ) Unfortunately, the CompositeNamingStrategy can only be used for extraction as it will not know how to handle the keys necessary for hydration ( foo and bar_bat , respectively). To rectify this we have to cover the keys for both hydration and extraction in our composite strategy: class Foo { public $bar; public $barBat; } $mapStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' =&gt; 'bar' ]); $underscoreNamingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ // Define both directions for the foo =&gt; bar mapping 'bar' =&gt; $mapStrategy, 'foo' =&gt; $mapStrategy, // Define both directions for the barBat =&gt; bar_bat mapping 'barBat' =&gt; $underscoreNamingStrategy, 'bar_bat' =&gt; $underscoreNamingStrategy, ]); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $foo-&gt;bar = 123; $foo-&gt;barBat = 42; $array = $hydrator-&gt;extract($foo); print_r($foo); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 ) print_r($array); // Array ( [foo] =&gt; 123 [bar_bat] =&gt; 42 ) $foo2 = new Foo(); $hydrator-&gt;hydrate($array, $foo2); print_r($foo2); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 )","title":"Basic Usage"},{"location":"v3/naming-strategy/identity-naming-strategy/","text":"IdentityNamingStrategy Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy uses the keys provided to it for hydration and extraction. Basic Usage $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); echo $namingStrategy-&gt;hydrate('foo'); // outputs: foo echo $namingStrategy-&gt;extract('bar'); // outputs: bar This strategy can be used in hydrators as well: class Foo { public $foo; } $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator-&gt;hydrate(array('foo' =&gt; 123), $foo); print_r($foo); // Foo Object ( [foo] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 )","title":"Identity"},{"location":"v3/naming-strategy/identity-naming-strategy/#identitynamingstrategy","text":"Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy uses the keys provided to it for hydration and extraction.","title":"IdentityNamingStrategy"},{"location":"v3/naming-strategy/identity-naming-strategy/#basic-usage","text":"$namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); echo $namingStrategy-&gt;hydrate('foo'); // outputs: foo echo $namingStrategy-&gt;extract('bar'); // outputs: bar This strategy can be used in hydrators as well: class Foo { public $foo; } $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator-&gt;hydrate(array('foo' =&gt; 123), $foo); print_r($foo); // Foo Object ( [foo] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 )","title":"Basic Usage"},{"location":"v3/naming-strategy/intro/","text":"Naming Strategies Sometimes, the representation of a property should not share the same name as the property itself. As an example, when serializing an object for a JSON payload, you may want to convert camelCase properties to underscore_separated properties, and vice versa when deserializing JSON to an object. To make that possible, laminas-hydrator provides naming strategies . These are similar to strategies , but instead of operating on the value , they operate on the name . NamingStrategyInterface Naming strategies implement Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface : namespace Laminas\\Hydrator\\NamingStrategy; /** * Allow property extraction / hydration for hydrator */ interface NamingStrategyInterface { /** * Converts the given name so that it can be extracted by the hydrator. * * @param null|mixed[] $data The original data for context. */ public function hydrate(string $name, ?array $data = null) : string; /** * Converts the given name so that it can be hydrated by the hydrator. * * @param null|object $object The original object for context. */ public function extract(string $name, ?object $object = null) : string; } Providing naming strategies Hydrators can indicate they will consume naming strategies, as well as allow registration of them, by implementing Laminas\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface : namespace Laminas\\Hydrator\\NamingStrategy; interface NamingStrategyEnabledInterface { /** * Sets the naming strategy. */ public function setNamingStrategy(NamingStrategyInterface $strategy) : void; /** * Gets the naming strategy. */ public function getNamingStrategy() : NamingStrategyInterface; /** * Checks if a naming strategy exists. */ public function hasNamingStrategy() : bool; /** * Removes the naming strategy. */ public function removeNamingStrategy() : void; } We provide a default implementation of this interface within the Laminas\\Hydrator\\AbstractHydrator definition. Its getNamingStrategy() will lazy-load an IdentityNamingStrategy if none has been previously registered. Since all shipped hydrators extend AbstractHydrator , they can consume naming strategies. Shipped naming strategies We provide the following naming strategies: CompositeNamingStrategy IdentityNamingStrategy MapNamingStrategy UnderscoreNamingStrategy","title":"Introduction"},{"location":"v3/naming-strategy/intro/#naming-strategies","text":"Sometimes, the representation of a property should not share the same name as the property itself. As an example, when serializing an object for a JSON payload, you may want to convert camelCase properties to underscore_separated properties, and vice versa when deserializing JSON to an object. To make that possible, laminas-hydrator provides naming strategies . These are similar to strategies , but instead of operating on the value , they operate on the name .","title":"Naming Strategies"},{"location":"v3/naming-strategy/intro/#namingstrategyinterface","text":"Naming strategies implement Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface : namespace Laminas\\Hydrator\\NamingStrategy; /** * Allow property extraction / hydration for hydrator */ interface NamingStrategyInterface { /** * Converts the given name so that it can be extracted by the hydrator. * * @param null|mixed[] $data The original data for context. */ public function hydrate(string $name, ?array $data = null) : string; /** * Converts the given name so that it can be hydrated by the hydrator. * * @param null|object $object The original object for context. */ public function extract(string $name, ?object $object = null) : string; }","title":"NamingStrategyInterface"},{"location":"v3/naming-strategy/intro/#providing-naming-strategies","text":"Hydrators can indicate they will consume naming strategies, as well as allow registration of them, by implementing Laminas\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface : namespace Laminas\\Hydrator\\NamingStrategy; interface NamingStrategyEnabledInterface { /** * Sets the naming strategy. */ public function setNamingStrategy(NamingStrategyInterface $strategy) : void; /** * Gets the naming strategy. */ public function getNamingStrategy() : NamingStrategyInterface; /** * Checks if a naming strategy exists. */ public function hasNamingStrategy() : bool; /** * Removes the naming strategy. */ public function removeNamingStrategy() : void; } We provide a default implementation of this interface within the Laminas\\Hydrator\\AbstractHydrator definition. Its getNamingStrategy() will lazy-load an IdentityNamingStrategy if none has been previously registered. Since all shipped hydrators extend AbstractHydrator , they can consume naming strategies.","title":"Providing naming strategies"},{"location":"v3/naming-strategy/intro/#shipped-naming-strategies","text":"We provide the following naming strategies: CompositeNamingStrategy IdentityNamingStrategy MapNamingStrategy UnderscoreNamingStrategy","title":"Shipped naming strategies"},{"location":"v3/naming-strategy/map-naming-strategy/","text":"MapNamingStrategy Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy allows you to provide a map of keys to use both during extraction and hydration; the map will translate the key based on the direction: When a map is provided for hydration, but not extraction, the strategy will perform an array_flip on the hydration map when performing lookups. You can create an instance with this behavior using MapNamingStrategy::createFromHydrationMap(array $hydrationMap) : MapNamingStrategy . When a map is provided for extraction, but not hydration, the strategy will perform an array_flip on the extraction map when performing lookups. You can create an instance with this behavior using MapNamingStrategy::createFromExtractionMap(array $extractionMap) : MapNamingStrategy . When maps are provided for both extraction and hydration, the appropriate map will be used during extraction and hydration operations. You can create an instance with this behavior using MapNamingStrategy::createFromAsymmetricMap(array $extractionMap, array $hydrationStrategy) : MapNamingStrategy . Most of the time, you will want your maps symmetrical; as such, set either a hydration map or an extraction map, but not both. Creating maps Hydration map only $namingStrategy = Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap( [ 'foo' =&gt; 'bar', 'baz' =&gt; 'bash' ] ); echo $namingStrategy-&gt;extract('bar'); // outputs: foo echo $namingStrategy-&gt;extract('bash'); // outputs: baz echo $namingStrategy-&gt;hydrate('foo'); // outputs: bar echo $namingStrategy-&gt;hydrate('baz'); // outputs: bash Extraction map only $namingStrategy = Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromExtractionMap( [ 'foo' =&gt; 'bar', 'baz' =&gt; 'bash' ] ); echo $namingStrategy-&gt;extract('foo'); // outputs: bar echo $namingStrategy-&gt;extract('baz'); // outputs: bash echo $namingStrategy-&gt;hydrate('bar'); // outputs: foo echo $namingStrategy-&gt;hydrate('bash'); // outputs: baz Both hydration and extraction maps $namingStrategy = Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromAsymmetricMap( [ 'foo' =&gt; 'bar', 'baz' =&gt; 'bash' ], [ 'is_bar' =&gt; 'foo', 'bashable' =&gt; 'baz', ] ); echo $namingStrategy-&gt;extract('foo'); // outputs: bar echo $namingStrategy-&gt;extract('baz'); // outputs: bash echo $namingStrategy-&gt;hydrate('is_bar'); // outputs: foo echo $namingStrategy-&gt;hydrate('bashable'); // outputs: baz Mapping keys for hydrators This strategy can be used in hydrators to dictate how keys should be mapped: class Foo { public $bar; } $namingStrategy = Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap([ 'foo' =&gt; 'bar', 'baz' =&gt; 'bash', ]); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator-&gt;hydrate(['foo' =&gt; 123], $foo); print_r($foo); // Foo Object ( [bar] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( \"foo\" =&gt; 123 )","title":"Mapping"},{"location":"v3/naming-strategy/map-naming-strategy/#mapnamingstrategy","text":"Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy allows you to provide a map of keys to use both during extraction and hydration; the map will translate the key based on the direction: When a map is provided for hydration, but not extraction, the strategy will perform an array_flip on the hydration map when performing lookups. You can create an instance with this behavior using MapNamingStrategy::createFromHydrationMap(array $hydrationMap) : MapNamingStrategy . When a map is provided for extraction, but not hydration, the strategy will perform an array_flip on the extraction map when performing lookups. You can create an instance with this behavior using MapNamingStrategy::createFromExtractionMap(array $extractionMap) : MapNamingStrategy . When maps are provided for both extraction and hydration, the appropriate map will be used during extraction and hydration operations. You can create an instance with this behavior using MapNamingStrategy::createFromAsymmetricMap(array $extractionMap, array $hydrationStrategy) : MapNamingStrategy . Most of the time, you will want your maps symmetrical; as such, set either a hydration map or an extraction map, but not both.","title":"MapNamingStrategy"},{"location":"v3/naming-strategy/map-naming-strategy/#creating-maps","text":"","title":"Creating maps"},{"location":"v3/naming-strategy/map-naming-strategy/#mapping-keys-for-hydrators","text":"This strategy can be used in hydrators to dictate how keys should be mapped: class Foo { public $bar; } $namingStrategy = Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap([ 'foo' =&gt; 'bar', 'baz' =&gt; 'bash', ]); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator-&gt;hydrate(['foo' =&gt; 123], $foo); print_r($foo); // Foo Object ( [bar] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( \"foo\" =&gt; 123 )","title":"Mapping keys for hydrators"},{"location":"v3/naming-strategy/underscore-naming-strategy/","text":"UnderscoreNamingStrategy Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy converts snake case strings (e.g. foo_bar_baz ) to camel-case strings (e.g. fooBarBaz ) and vice versa. Basic Usage $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); echo $namingStrategy-&gt;extract('foo_bar'); // outputs: foo_bar echo $namingStrategy-&gt;extract('Foo_Bar'); // outputs: foo_bar echo $namingStrategy-&gt;extract('FooBar'); // outputs: foo_bar echo $namingStrategy-&gt;hydrate('fooBar'); // outputs: fooBar echo $namingStrategy-&gt;hydrate('FooBar'); // outputs: fooBar echo $namingStrategy-&gt;hydrate('Foo_Bar'); // outputs: fooBar This strategy can be used in hydrators to dictate how keys should be mapped. class Foo { public $fooBar; } $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy(new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy()); $foo = new Foo(); $hydrator-&gt;hydrate(['foo_bar' =&gt; 123], $foo); print_r($foo); // Foo Object ( [fooBar] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo_bar] =&gt; 123 )","title":"Underscore Mapping"},{"location":"v3/naming-strategy/underscore-naming-strategy/#underscorenamingstrategy","text":"Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy converts snake case strings (e.g. foo_bar_baz ) to camel-case strings (e.g. fooBarBaz ) and vice versa.","title":"UnderscoreNamingStrategy"},{"location":"v3/naming-strategy/underscore-naming-strategy/#basic-usage","text":"$namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); echo $namingStrategy-&gt;extract('foo_bar'); // outputs: foo_bar echo $namingStrategy-&gt;extract('Foo_Bar'); // outputs: foo_bar echo $namingStrategy-&gt;extract('FooBar'); // outputs: foo_bar echo $namingStrategy-&gt;hydrate('fooBar'); // outputs: fooBar echo $namingStrategy-&gt;hydrate('FooBar'); // outputs: fooBar echo $namingStrategy-&gt;hydrate('Foo_Bar'); // outputs: fooBar This strategy can be used in hydrators to dictate how keys should be mapped. class Foo { public $fooBar; } $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy(new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy()); $foo = new Foo(); $hydrator-&gt;hydrate(['foo_bar' =&gt; 123], $foo); print_r($foo); // Foo Object ( [fooBar] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo_bar] =&gt; 123 )","title":"Basic Usage"},{"location":"v3/strategies/collection/","text":"Collection The CollectionStrategy can be used to hydrate a collection of objects with data from an array with multiple items and vice versa . The strategy uses a hydrator to hydrate and extract data from each item of a collection. Basic usage The following code example shows standalone usage without adding the strategy to a hydrator. Create and configure strategy Create the strategy and set a hydrator and a classname for the handled object items. $strategy = new Laminas\\Hydrator\\Strategy\\CollectionStrategy( new Laminas\\Hydrator\\ObjectPropertyHydrator(), stdClass::class ); Hydrate data $hydrated = $strategy-&gt;hydrate([ [ 'title' =&gt; 'Modern Love', 'duration' =&gt; '4:46', ], [ 'title' =&gt; 'China Girl', 'duration' =&gt; '5:32', ], // … ]); echo $hydrated[1]-&gt;title; // 'China Girl' echo $hydrated[1]-&gt;duration; // '5:32' Extract data // Define array with objects $track1 = new stdClass(); $track1-&gt;title = 'Modern Love'; $track1-&gt;duration = '4:46'; $track2 = new stdClass(); $track2-&gt;title = 'China Girl'; $track2-&gt;duration = '5:32'; $data = [ $track1, $track2, ]; // Extract $extracted = $strategy-&gt;extract($data); var_dump($extracted); /* array(2) { [0] =&gt; array(2) { 'title' =&gt; string(11) \"Modern Love\" 'duration' =&gt; string(4) \"4:46\" } [1] =&gt; array(2) { 'title' =&gt; string(10) \"China Girl\" 'duration' =&gt; string(4) \"5:32\" } } */ Example The following example shows the hydration for a class with a property that consumes array of classes. An example class which represents a music album with tracks. class Album { private ?string $title; private ?string $artist; private array $tracks; public function __construct( ?string $title = null, ?string $artist = null, array $tracks = [] ) { $this-&gt;title = $title; $this-&gt;artist = $artist; $this-&gt;tracks = $tracks; } public function getTitle() : ?string { return $this-&gt;title; } public function getArtist() : ?string { return $this-&gt;artist; } public function getTracks() : array { return $this-&gt;tracks; } } An example class representing a track of an album. class Track { private ?string $title; private ?string $duration; public function __construct( ?string $title = null, ?string $duration = null ) { $this-&gt;title = $title; $this-&gt;duration = $duration; } public function getTitle() : ?string { return $this-&gt;title; } public function getDuration() : ?string { return $this-&gt;duration; } } Create hydrator and add strategy Create a hydrator and add CollectionStrategy as a strategy, with a hydrator and a classname for the handled object items. $hydrator = new Laminas\\Hydrator\\ReflectionHydrator(); $hydrator-&gt;addStrategy( 'tracks', new Laminas\\Hydrator\\Strategy\\CollectionStrategy( new Laminas\\Hydrator\\ReflectionHydrator(), Track::class ) ); Hydrate data Create an instance of the example Album class and hydrate data. $album = new Album(); $hydrator-&gt;hydrate( [ 'artist' =&gt; 'David Bowie', 'title' =&gt; 'Let\\'s Dance', 'tracks' =&gt; [ [ 'title' =&gt; 'Modern Love', 'duration' =&gt; '4:46', ], [ 'title' =&gt; 'China Girl', 'duration' =&gt; '5:32', ], [ 'title' =&gt; 'Let\\'s Dance', 'duration' =&gt; '7:38', ], // … ], ], $album ); echo $album-&gt;getTitle(); // \"Let's Dance\" echo $album-&gt;getArtist(); // 'David Bowie' echo $album-&gt;getTracks()[1]-&gt;getTitle(); // 'China Girl' echo $album-&gt;getTracks()[1]-&gt;getDuration(); // '5:32' Extract data var_dump($hydrator-&gt;extract($album)); /* array(3) { 'title' =&gt; string(11) \"Let's Dance\" 'artist' =&gt; string(11) \"David Bowie\" 'tracks' =&gt; array(3) { [0] =&gt; array(2) { 'title' =&gt; string(11) \"Modern Love\" 'duration' =&gt; string(4) \"4:46\" } [1] =&gt; array(2) { 'title' =&gt; string(10) \"China Girl\" 'duration' =&gt; string(4) \"5:32\" } [2] =&gt; array(2) { 'title' =&gt; string(11) \"Let's Dance\" 'duration' =&gt; string(4) \"7:38\" } } } */","title":"Collection"},{"location":"v3/strategies/collection/#collection","text":"The CollectionStrategy can be used to hydrate a collection of objects with data from an array with multiple items and vice versa . The strategy uses a hydrator to hydrate and extract data from each item of a collection.","title":"Collection"},{"location":"v3/strategies/collection/#basic-usage","text":"The following code example shows standalone usage without adding the strategy to a hydrator.","title":"Basic usage"},{"location":"v3/strategies/collection/#example","text":"The following example shows the hydration for a class with a property that consumes array of classes. An example class which represents a music album with tracks. class Album { private ?string $title; private ?string $artist; private array $tracks; public function __construct( ?string $title = null, ?string $artist = null, array $tracks = [] ) { $this-&gt;title = $title; $this-&gt;artist = $artist; $this-&gt;tracks = $tracks; } public function getTitle() : ?string { return $this-&gt;title; } public function getArtist() : ?string { return $this-&gt;artist; } public function getTracks() : array { return $this-&gt;tracks; } } An example class representing a track of an album. class Track { private ?string $title; private ?string $duration; public function __construct( ?string $title = null, ?string $duration = null ) { $this-&gt;title = $title; $this-&gt;duration = $duration; } public function getTitle() : ?string { return $this-&gt;title; } public function getDuration() : ?string { return $this-&gt;duration; } }","title":"Example"},{"location":"v3/strategies/datetime-immutable-formatter-strategy/","text":"DateTimeImmutableFormatter Available since version 3.1.0 DateTimeImmutableFormatterStrategy provides bidirectional conversion between strings and DateTimeImmutable instances . The strategy uses DateTimeFormatterStrategy for conversion where the input and output formats can be set. Basic Usage The following code example shows standalone usage without adding the strategy to a hydrator. Create and configure strategy Create the strategy and set the input and output formats via the DateTimeFormatterStrategy . $strategy = new Laminas\\Hydrator\\Strategy\\DateTimeImmutableFormatterStrategy( new Laminas\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d') ); Hydrate data $hydrated = $strategy-&gt;hydrate('2020-07-01'); var_dump($hydrated instanceof DateTimeImmutable); // true Extract data $extracted = $strategy-&gt;extract( DateTimeImmutable::createFromFormat('Y-m-d', '2020-07-01') ); echo $extracted // '2020-07-01' Example The following example demonstrates hydration for a class with a property. An example class which represents a music album with a release date: class Album { private ?DateTimeImmutable $releaseDate; public function __construct(?DateTimeImmutable $releaseDate = null) { $this-&gt;releaseDate = $releaseDate; } public function getReleaseDate() : ?DateTimeImmutable { return $this-&gt;releaseDate; } } Create hydrator and add strategy Create a hydrator and add DateTimeImmutableFormatterStrategy as strategy: $hydrator = new Laminas\\Hydrator\\ReflectionHydrator(); $hydrator-&gt;addStrategy( 'releaseDate', new Laminas\\Hydrator\\Strategy\\DateTimeImmutableFormatterStrategy( new Laminas\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d') ) ); Hydrate data Create an instance of the example class and hydrate data: $album = new Album(); $hydrator-&gt;hydrate(['releaseDate' =&gt; '2020-07-01'], $album); var_dump($album-&gt;getReleaseDate() instanceof DateTimeImmutable); // true Extract data $extracted = $hydrator-&gt;extract($album); echo $extracted; // '2020-07-01'","title":"DateTimeImmutableFormatter"},{"location":"v3/strategies/datetime-immutable-formatter-strategy/#datetimeimmutableformatter","text":"Available since version 3.1.0 DateTimeImmutableFormatterStrategy provides bidirectional conversion between strings and DateTimeImmutable instances . The strategy uses DateTimeFormatterStrategy for conversion where the input and output formats can be set.","title":"DateTimeImmutableFormatter"},{"location":"v3/strategies/datetime-immutable-formatter-strategy/#basic-usage","text":"The following code example shows standalone usage without adding the strategy to a hydrator.","title":"Basic Usage"},{"location":"v3/strategies/datetime-immutable-formatter-strategy/#example","text":"The following example demonstrates hydration for a class with a property. An example class which represents a music album with a release date: class Album { private ?DateTimeImmutable $releaseDate; public function __construct(?DateTimeImmutable $releaseDate = null) { $this-&gt;releaseDate = $releaseDate; } public function getReleaseDate() : ?DateTimeImmutable { return $this-&gt;releaseDate; } }","title":"Example"},{"location":"v3/strategies/hydrator/","text":"Hydrator Available since version 3.1.0 The HydratorStrategy can be used to hydrate an object and its child objects with data from a nested array and vice versa . Basic usage The following code example shows standalone usage without adding the strategy to a hydrator. Create and configure strategy Create the strategy and set a hydrator and a classname for the handled object. $strategy = new Laminas\\Hydrator\\Strategy\\HydratorStrategy( new Laminas\\Hydrator\\ObjectPropertyHydrator(), stdClass::class ); Hydrate data $hydrated = $strategy-&gt;hydrate([ 'firstName' =&gt; 'David', 'lastName' =&gt; 'Bowie', ]); echo $hydrated-&gt;firstName; // 'David' echo $hydrated-&gt;lastName; // 'Bowie' Extract data $class = new stdClass(); $class-&gt;firstName = 'David'; $class-&gt;lastName = 'Bowie'; $extracted = $strategy-&gt;extract($class); var_dump($extracted); // ['firstName' =&gt; 'David', 'lastName' =&gt; 'Bowie'] Example The following example shows the hydration for a class with a property that consumes another class. An example class which represents a music album. class Album { private ?int $id = null; private ?string $title = null; private ?Artist $artist = null; public function __construct( ?int $id = null, ?string $title = null, ?Artist $artist = null ) { $this-&gt;id = $id; $this-&gt;title = $title; $this-&gt;artist = $artist; } public function getId() : ?int { return $this-&gt;id; } public function getTitle() : ?string { return $this-&gt;title; } public function getArtist() : ?Artist { return $this-&gt;artist; } } An example class representing the artist of an album. class Artist { private ?string $firstName; private ?string $lastName; public function __construct( ?string $firstName = null, ?string $lastName = null ) { $this-&gt;firstName = $firstName; $this-&gt;lastName = $lastName; } public function getFirstName() : ?string { return $this-&gt;firstName; } public function getLastName() : ?string { return $this-&gt;lastName; } } Create hydrator and add strategy Create a hydrator and add HydratorStrategy as a strategy, with a hydrator and a classname for the handled object. $hydrator = new Laminas\\Hydrator\\ReflectionHydrator(); $hydrator-&gt;addStrategy( 'artist', new Laminas\\Hydrator\\Strategy\\HydratorStrategy( new Laminas\\Hydrator\\ReflectionHydrator(), Artist::class ) ); Hydrate data Create an instance of the example Album class and hydrate data. $album = new Album(); $hydrator-&gt;hydrate( [ 'id' =&gt; 100, 'title' =&gt; 'The Next Day (Deluxe Version)', 'artist' =&gt; [ 'firstName' =&gt; 'David', 'lastName' =&gt; 'Bowie', ], ], $album ); echo $album-&gt;getTitle(); // 'The Next Day (Deluxe Version)' echo $album-&gt;getArtist()-&gt;getFirstName(); // 'David' echo $album-&gt;getArtist()-&gt;getLastName(); // 'Bowie' Extract data var_dump($hydrator-&gt;extract($album)); /* array(3) { 'id' =&gt; int(100) 'title' =&gt; string(29) \"The Next Day (Deluxe Version)\" 'artist' =&gt; array(2) { 'firstName' =&gt; string(5) \"David\" 'lastName' =&gt; string(5) \"Bowie\" } } */","title":"Hydrator"},{"location":"v3/strategies/hydrator/#hydrator","text":"Available since version 3.1.0 The HydratorStrategy can be used to hydrate an object and its child objects with data from a nested array and vice versa .","title":"Hydrator"},{"location":"v3/strategies/hydrator/#basic-usage","text":"The following code example shows standalone usage without adding the strategy to a hydrator.","title":"Basic usage"},{"location":"v3/strategies/hydrator/#example","text":"The following example shows the hydration for a class with a property that consumes another class. An example class which represents a music album. class Album { private ?int $id = null; private ?string $title = null; private ?Artist $artist = null; public function __construct( ?int $id = null, ?string $title = null, ?Artist $artist = null ) { $this-&gt;id = $id; $this-&gt;title = $title; $this-&gt;artist = $artist; } public function getId() : ?int { return $this-&gt;id; } public function getTitle() : ?string { return $this-&gt;title; } public function getArtist() : ?Artist { return $this-&gt;artist; } } An example class representing the artist of an album. class Artist { private ?string $firstName; private ?string $lastName; public function __construct( ?string $firstName = null, ?string $lastName = null ) { $this-&gt;firstName = $firstName; $this-&gt;lastName = $lastName; } public function getFirstName() : ?string { return $this-&gt;firstName; } public function getLastName() : ?string { return $this-&gt;lastName; } }","title":"Example"},{"location":"v3/strategies/serializable/","text":"Serializable The SerializableStrategy can be used for serializing and deserializing PHP types to and from different representations . The strategy uses laminas-serializer for serializing and deserializing of data. Basic usage The following code example shows standalone usage without adding the strategy to a hydrator. Create and configure strategy Create the strategy and set a serializer adapter. $strategy = new Laminas\\Hydrator\\Strategy\\SerializableStrategy( new Laminas\\Serializer\\Adapter\\Json() ); For available serializer adapters see the documentation of laminas-serializer . Hydrate data $json = '[{\"title\":\"Modern Love\",\"duration\":\"4:46\"},{\"title\":\"China Girl\",\"duration\":\"5:32\"}]'; $hydrated = $strategy-&gt;hydrate($json); echo $hydrated[1]['title']; // 'China Girl' echo $hydrated[1]['duration']; // '5:32' Extract data $data = [ [ 'title' =&gt; 'Modern Love', 'duration' =&gt; '4:46', ], [ 'title' =&gt; 'China Girl', 'duration' =&gt; '5:32', ], // … ]; $extracted = $strategy-&gt;extract($data); echo $extracted; // '[{\"title\":\"Modern Love\",\"duration\":\"4:46\"},{\"title\":\"China Girl\",\"duration\":\"5:32\"}]' Example The following example shows the hydration for a class with a property where the data is provided by a JSON string. An example class which represents a music album with tracks. class Album { private ?string $title; private ?string $artist; private array $tracks; public function __construct( ?string $title = null, ?string $artist = null, array $tracks = [] ) { $this-&gt;title = $title; $this-&gt;artist = $artist; $this-&gt;tracks = $tracks; } public function getTitle() : ?string { return $this-&gt;title; } public function getArtist() : ?string { return $this-&gt;artist; } public function getTracks() : array { return $this-&gt;tracks; } } Create hydrator and add strategy Create a hydrator and add SerializableStrategy as a strategy, with a serializer adapter which converts the JSON string to array and vice versa. $hydrator = new Laminas\\Hydrator\\ReflectionHydrator(); $hydrator-&gt;addStrategy( 'tracks', new Laminas\\Hydrator\\Strategy\\SerializableStrategy( new Laminas\\Serializer\\Adapter\\Json() ) ); Hydrate data Create an instance of the example Album class and hydrate data. $album = new Album(); $hydrator-&gt;hydrate( [ 'artist' =&gt; 'David Bowie', 'title' =&gt; 'Let\\'s Dance', 'tracks' =&gt; '[{\"title\":\"Modern Love\",\"duration\":\"4:46\"},{\"title\":\"China Girl\",\"duration\":\"5:32\"}]', ], $album ); echo $album-&gt;getTitle(); // \"Let's Dance\" echo $album-&gt;getArtist(); // 'David Bowie' echo $album-&gt;getTracks()[1]['title']; // 'China Girl' echo $album-&gt;getTracks()[1]['duration']; // '5:32' Extract data var_dump($hydrator-&gt;extract($album)); /* array(3) { 'title' =&gt; string(11) \"Let's Dance\" 'artist' =&gt; string(11) \"David Bowie\" 'tracks' =&gt; string(84) \"[{\"title\":\"Modern Love\",\"duration\":\"4:46\"},{\"title\":\"China Girl\",\"duration\":\"5:32\"}]\" } */","title":"Serializable"},{"location":"v3/strategies/serializable/#serializable","text":"The SerializableStrategy can be used for serializing and deserializing PHP types to and from different representations . The strategy uses laminas-serializer for serializing and deserializing of data.","title":"Serializable"},{"location":"v3/strategies/serializable/#basic-usage","text":"The following code example shows standalone usage without adding the strategy to a hydrator.","title":"Basic usage"},{"location":"v3/strategies/serializable/#example","text":"The following example shows the hydration for a class with a property where the data is provided by a JSON string. An example class which represents a music album with tracks. class Album { private ?string $title; private ?string $artist; private array $tracks; public function __construct( ?string $title = null, ?string $artist = null, array $tracks = [] ) { $this-&gt;title = $title; $this-&gt;artist = $artist; $this-&gt;tracks = $tracks; } public function getTitle() : ?string { return $this-&gt;title; } public function getArtist() : ?string { return $this-&gt;artist; } public function getTracks() : array { return $this-&gt;tracks; } }","title":"Example"},{"location":"v4/aggregate/","text":"AggregateHydrator Laminas\\Hydrator\\Aggregate\\AggregateHydrator is an implementation of Laminas\\Hydrator\\HydratorInterface that composes multiple hydrators via event listeners. You typically want to use an aggregate hydrator when you want to hydrate or extract data from complex objects that implement multiple interfaces, and therefore need multiple hydrators to handle that in subsequent steps. Installation requirements The AggregateHydrator depends on the laminas-eventmanager component, so be sure to have it installed before getting started: $ composer require laminas/laminas-eventmanager Basic usage A simple use case may be hydrating a BlogPost object, which contains data for the user that created it, the time it was created, the current publishing status, etc: use Laminas\\Hydrator\\Aggregate\\AggregateHydrator; $hydrator = new AggregateHydrator(); // attach the various hydrators capable of handling simpler interfaces $hydrator-&gt;add(new My\\BlogPostHydrator()); $hydrator-&gt;add(new My\\UserAwareObjectHydrator()); $hydrator-&gt;add(new My\\TimestampedObjectHydrator()); $hydrator-&gt;add(new My\\PublishableObjectHydrator()); // ... // Now retrieve the BlogPost object // ... // you can now extract complex data from a blogpost $data = $hydrator-&gt;extract($blogPost); // or you can fill the object with complex data $blogPost = $hydrator-&gt;hydrate($data, $blogPost); Hydrator priorities AggregateHydrator::add has a second optional argument, $priority . If you have two or more hydrators that conflict with each other for same data keys, you may decide which one to execute first or last by passing a higher or lower integer priority, respectively, to this argument. In order to work with this logic, each of the hydrators that are attached should ignore any unknown object type passed in: namespace My; use Laminas\\Hydrator\\HydratorInterface class BlogPostHydrator implements HydratorInterface { public function hydrate($data, $object) { if (! $object instanceof BlogPost) { return $object; } // ... continue hydration ... } public function extract($object) { if (! $object instanceof BlogPost) { return array(); } // ... continue extraction ... } } Advanced use cases Since the AggregateHydrator is event-driven, you can use the EventManager API to tweak its behaviour. Common use cases include: Removal of hydrated data keys (passwords/confidential information) depending on business rules. Caching of the hydration/extraction process. Transformations on extracted data, for compatibility with third-party APIs. In the following example, a cache listener is introduced to speed up hydration, which can be very useful when the same data is requested multiple times: use Laminas\\Hydrator\\Aggregate\\AggregateHydrator; use Laminas\\Hydrator\\Aggregate\\ExtractEvent; use Laminas\\Cache\\Storage\\Adapter\\Memory; $hydrator = new AggregateHydrator(); // Attach the various hydrators: $hydrator-&gt;add(new My\\BlogPostHydrator()); $hydrator-&gt;add(new My\\UserAwareObjectHydrator()); $hydrator-&gt;add(new My\\TimestampedObjectHydrator()); $hydrator-&gt;add(new My\\PublishableObjectHydrator()); // ... $cache = new Memory(); $cacheReadListener = function (ExtractEvent $event) use ($cache) { $object = $event-&gt;getExtractionObject(); if (! $object instanceof BlogPost) { return; } if ($cache-&gt;hasItem($object-&gt;getId())) { $event-&gt;setExtractedData($cache-&gt;getItem($object-&gt;getId())); $event-&gt;stopPropagation(); } }; $cacheWriteListener = function (ExtractEvent $event) use ($cache) { $object = $event-&gt;getExtractionObject(); if (! $object instanceof BlogPost) { return; } $cache-&gt;setItem($object-&gt;getId(), $event-&gt;getExtractedData()); }; // Attaching a high priority listener executed before extraction logic: $eventManager = $hydrator-&gt;getEventManager(); $eventManager()-&gt;attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000); // Attaching a low priority listener executed after extraction logic: $eventManager()-&gt;attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000); With an aggregate hydrator configured in this way, any $hydrator-&gt;extract($blogPost) operation will be cached.","title":"Aggregates"},{"location":"v4/aggregate/#aggregatehydrator","text":"Laminas\\Hydrator\\Aggregate\\AggregateHydrator is an implementation of Laminas\\Hydrator\\HydratorInterface that composes multiple hydrators via event listeners. You typically want to use an aggregate hydrator when you want to hydrate or extract data from complex objects that implement multiple interfaces, and therefore need multiple hydrators to handle that in subsequent steps.","title":"AggregateHydrator"},{"location":"v4/aggregate/#installation-requirements","text":"The AggregateHydrator depends on the laminas-eventmanager component, so be sure to have it installed before getting started: $ composer require laminas/laminas-eventmanager","title":"Installation requirements"},{"location":"v4/aggregate/#basic-usage","text":"A simple use case may be hydrating a BlogPost object, which contains data for the user that created it, the time it was created, the current publishing status, etc: use Laminas\\Hydrator\\Aggregate\\AggregateHydrator; $hydrator = new AggregateHydrator(); // attach the various hydrators capable of handling simpler interfaces $hydrator-&gt;add(new My\\BlogPostHydrator()); $hydrator-&gt;add(new My\\UserAwareObjectHydrator()); $hydrator-&gt;add(new My\\TimestampedObjectHydrator()); $hydrator-&gt;add(new My\\PublishableObjectHydrator()); // ... // Now retrieve the BlogPost object // ... // you can now extract complex data from a blogpost $data = $hydrator-&gt;extract($blogPost); // or you can fill the object with complex data $blogPost = $hydrator-&gt;hydrate($data, $blogPost);","title":"Basic usage"},{"location":"v4/aggregate/#advanced-use-cases","text":"Since the AggregateHydrator is event-driven, you can use the EventManager API to tweak its behaviour. Common use cases include: Removal of hydrated data keys (passwords/confidential information) depending on business rules. Caching of the hydration/extraction process. Transformations on extracted data, for compatibility with third-party APIs. In the following example, a cache listener is introduced to speed up hydration, which can be very useful when the same data is requested multiple times: use Laminas\\Hydrator\\Aggregate\\AggregateHydrator; use Laminas\\Hydrator\\Aggregate\\ExtractEvent; use Laminas\\Cache\\Storage\\Adapter\\Memory; $hydrator = new AggregateHydrator(); // Attach the various hydrators: $hydrator-&gt;add(new My\\BlogPostHydrator()); $hydrator-&gt;add(new My\\UserAwareObjectHydrator()); $hydrator-&gt;add(new My\\TimestampedObjectHydrator()); $hydrator-&gt;add(new My\\PublishableObjectHydrator()); // ... $cache = new Memory(); $cacheReadListener = function (ExtractEvent $event) use ($cache) { $object = $event-&gt;getExtractionObject(); if (! $object instanceof BlogPost) { return; } if ($cache-&gt;hasItem($object-&gt;getId())) { $event-&gt;setExtractedData($cache-&gt;getItem($object-&gt;getId())); $event-&gt;stopPropagation(); } }; $cacheWriteListener = function (ExtractEvent $event) use ($cache) { $object = $event-&gt;getExtractionObject(); if (! $object instanceof BlogPost) { return; } $cache-&gt;setItem($object-&gt;getId(), $event-&gt;getExtractedData()); }; // Attaching a high priority listener executed before extraction logic: $eventManager = $hydrator-&gt;getEventManager(); $eventManager()-&gt;attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000); // Attaching a low priority listener executed after extraction logic: $eventManager()-&gt;attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000); With an aggregate hydrator configured in this way, any $hydrator-&gt;extract($blogPost) operation will be cached.","title":"Advanced use cases"},{"location":"v4/filter/","text":"Laminas\\Hydrator\\Filter Hydrator filters allow you to manipulate the behavior of the extract() operation. This is especially useful, if you want to omit some internals (e.g. getServiceManager() ) from the array representation. It comes with a helpful Composite implementation, and several filters for common use cases. The filters are composed in the AbstractHydrator , so you can start using them immediately in any custom extensions you write that extend that class. namespace Laminas\\Hydrator\\Filter; interface FilterInterface { /** * Should return true, if the given filter does not match. */ public function filter(string $property, ?object $instance = null) : bool; } If it returns true, the key/value pairs will be in the extracted arrays - if it returns false, you'll not see them again. The $instance value will typically be passed by extractors when the $object they are extracting is an anonymous object. (The ClassMethodsHydrator uses this facility, as the Reflection API does not work on anonymous objects.) Filter implementations Laminas\\Hydrator\\Filter\\GetFilter This filter is used in the ClassMethodsHydrator to decide which getters will be extracted. It checks if the key to extract starts with get or the object contains a method beginning with get (e.g., Laminas\\Foo\\Bar::getFoo ). Laminas\\Hydrator\\Filter\\HasFilter This filter is used in the ClassMethodsHydrator to decide which has methods will be extracted. It checks if the key to extract begins with has or the object contains a method beginning with has (e.g., Laminas\\Foo\\Bar::hasFoo ). Laminas\\Hydrator\\Filter\\IsFilter This filter is used in the ClassMethodsHydrator to decide which is methods will be extracted. It checks if the key to extract begins with is or the object contains a method beginning with is (e.g., Laminas\\Foo\\Bar::isFoo ). Laminas\\Hydrator\\Filter\\MethodMatchFilter This filter allows you to omit methods during extraction that match the condition defined in the composite. The name of the method is specified in the constructor of this filter; the second parameter decides whether to use white or blacklisting to decide (whitelisting retains only the matching method, blacklist omits any matching method). The default is blacklisting - pass false to change the behavior. Laminas\\Hydrator\\Filter\\NumberOfParameterFilter This filter is used in the ClassMethodsHydrator to check the number of parameters. By convention, the get , has and is methods do not get any parameters - but it may happen. You can add your own number of required parameters, simply add the number to the constructor. The default value is 0. If the method has more or fewer parameters than what the filter accepts, it will be omitted. Use FilterComposite for complex filters FilterComposite implements FilterInterface as well, so you can add it as a regular filter to the hydrator. One benefit of this implementation is that you can add the filters with a condition and accomplish complex requirements using different filters with different conditions. You can pass the following conditions to the 3rd parameter, when you add a filter: Laminas\\Hydrator\\Filter\\FilterComposite::CONDITION_OR At the given level of the composite, at least one filter set using CONDITION_OR must return true to extract the value. Laminas\\Hydrator\\Filter\\FilterComposite::CONDITION_AND At the given level of the composite, all filters set using CONDITION_AND must return true to extract the value. FilterComposite Examples To illustrate how conditions apply when composing filters, consider the following set of filters: $composite = new FilterComposite(); $composite-&gt;addFilter('one', $condition1); $composite-&gt;addFilter('two', $condition2); $composite-&gt;addFilter('three', $condition3); $composite-&gt;addFilter('four', $condition4, FilterComposite::CONDITION_AND); $composite-&gt;addFilter('five', $condition5, FilterComposite::CONDITION_AND); The above is roughly equivalent to the following conditional: // This is what's happening internally if ( ($condition1 || $condition2 || $condition3 ) &amp;&amp; ($condition4 &amp;&amp; $condition5 ) ) { // do extraction } If you only have one condition block (e.g., only AND or OR filters), the other condition type will be completely ignored. A bit more complex filter can look like this: $composite = new FilterComposite(); $composite-&gt;addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $composite-&gt;addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $hydrator-&gt;addFilter('excludes', $composite, FilterComposite::CONDITION_AND); // Internal if (( // default composite inside the ClassMethodsHydrator: ($getFilter || $hasFilter || $isFilter ) &amp;&amp; ( $numberOfParameterFilter ) ) &amp;&amp; ( // new composite, added to the one above $serviceManagerFilter &amp;&amp; $eventManagerFilter ) ) { // do extraction } If you perform this on the ClassMethodsHydrator , all getters will get extracted, except for getServiceManager() and getEventManager() . Using the provider interface Laminas\\Hydrator\\Filter\\FilterProviderInterface allows you to configure the behavior of the hydrator inside your objects. namespace Laminas\\Hydrator\\Filter; interface FilterProviderInterface { /** * Provides a filter for hydration * * @return FilterInterface */ public function getFilter(); } (The getFilter() method is automatically excluded from extract() .) If the extracted object implements the Laminas\\Hydrator\\Filter\\FilterProviderInterface , the returned FilterInterface instance can also be a FilterComposite . For example: Class Foo implements FilterProviderInterface { public function getFoo() { return 'foo'; } public function hasFoo() { return true; } public function getServiceManager() { return 'servicemanager'; } public function getEventManager() { return 'eventmanager'; } public function getFilter() { $composite = new FilterComposite(); $composite-&gt;addFilter('get', new GetFilter()); $exclusionComposite = new FilterComposite(); $exclusionComposite-&gt;addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $exclusionComposite-&gt;addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $composite-&gt;addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND); return $composite; } } $hydrator = new ClassMethodsHydrator(false); $extractedArray = $hydrator-&gt;extract(new Foo()); $extractedArray will only have 'foo' =&gt; 'foo'; all other values are excluded from extraction. Note All pre-registered filters from the ClassMethodsHydrator hydrator are ignored when this interface is used. More on those methods below. Filter-enabled hydrators and the composite filter Hydrators can indicate they are filter-enabled by implementing Laminas\\Hydrator\\Filter\\FilterEnabledInterface : namespace Laminas\\Hydrator\\Filter; interface FilterEnabledInterface extends FilterProviderInterface { /** * Add a new filter to take care of what needs to be hydrated. * To exclude e.g. the method getServiceLocator: * * &lt;code&gt; * $composite-&gt;addFilter( * \"servicelocator\", * function ($property) { * [$class, $method] = explode('::', $property, 2); * return $method !== 'getServiceLocator'; * }, * FilterComposite::CONDITION_AND * ); * &lt;/code&gt; * * @param string $name Index in the composite * @param callable|FilterInterface $filter */ public function addFilter(string $name, $filter, int $condition = FilterComposite::CONDITION_OR) : void; /** * Check whether a specific filter exists at key $name or not * * @param string $name Index in the composite */ public function hasFilter(string $name) : bool; /** * Remove a filter from the composition. * * To not extract \"has\" methods, you simply need to unregister it * * &lt;code&gt; * $filterComposite-&gt;removeFilter('has'); * &lt;/code&gt; */ public function removeFilter(string $name) : void; } Note that the interface extends FilterProviderInterface , which means it also includes the getFilter() method. The FilterEnabledInterface makes the assumption that the class will be backed by a Laminas\\Hydrator\\Filter\\FilterComposite ; the various addFilter() , hasFilter() , and removeFilter() methods are expected to proxy to a FilterComposite instance. AbstractHydrator , on which all the hydrators shipped in this package are built, implements FilterEnabledInterface . Of the hydrators shipped, only one, ClassMethodsHydrator , defines any filters from the outset. Its constructor includes the following: $this-&gt;filterComposite-&gt;addFilter('is', new IsFilter()); $this-&gt;filterComposite-&gt;addFilter('has', new HasFilter()); $this-&gt;filterComposite-&gt;addFilter('get', new GetFilter()); $this-&gt;filterComposite-&gt;addFilter( 'parameter', new NumberOfParameterFilter(), FilterComposite::CONDITION_AND ); Remove filters If you want to tell a filter-enabled hydrator such as ClassMethodsHydrator not to extract methods that start with is , remove the related filter: $hydrator = new ClassMethodsHydrator(false); $hydrator-&gt;removeFilter('is'); After performing the above, the key/value pairs for is methods will no longer end up in your extracted array. Add filters You can add filters using the addFilter() method. Filters can either implement FilterInterface , or simply be PHP callables: $hydrator-&gt;addFilter('len', function($property) { return strlen($property) === 3; }); By default, every filter you add will be added with a conditional OR . If you want to add it with AND (such as the ClassMethodsHydrator does with its composed NumberOfParameterFilter , demonstrated above) provide the conditon as the third argument to addFilter : $hydrator-&gt;addFilter('len', function($property) { return strlen($property) === 3; }, FilterComposite::CONDITION_AND); One common use case for filters is to omit getters for values that you do not want to represent, such as a service manager instance: $hydrator-&gt;addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); The example above will exclude the getServiceManager() method and the servicemanager key from extraction, even if the get filter wants to add it.","title":"Filters"},{"location":"v4/filter/#laminashydratorfilter","text":"Hydrator filters allow you to manipulate the behavior of the extract() operation. This is especially useful, if you want to omit some internals (e.g. getServiceManager() ) from the array representation. It comes with a helpful Composite implementation, and several filters for common use cases. The filters are composed in the AbstractHydrator , so you can start using them immediately in any custom extensions you write that extend that class. namespace Laminas\\Hydrator\\Filter; interface FilterInterface { /** * Should return true, if the given filter does not match. */ public function filter(string $property, ?object $instance = null) : bool; } If it returns true, the key/value pairs will be in the extracted arrays - if it returns false, you'll not see them again. The $instance value will typically be passed by extractors when the $object they are extracting is an anonymous object. (The ClassMethodsHydrator uses this facility, as the Reflection API does not work on anonymous objects.)","title":"Laminas\\Hydrator\\Filter"},{"location":"v4/filter/#filter-implementations","text":"","title":"Filter implementations"},{"location":"v4/filter/#use-filtercomposite-for-complex-filters","text":"FilterComposite implements FilterInterface as well, so you can add it as a regular filter to the hydrator. One benefit of this implementation is that you can add the filters with a condition and accomplish complex requirements using different filters with different conditions. You can pass the following conditions to the 3rd parameter, when you add a filter:","title":"Use FilterComposite for complex filters"},{"location":"v4/filter/#using-the-provider-interface","text":"Laminas\\Hydrator\\Filter\\FilterProviderInterface allows you to configure the behavior of the hydrator inside your objects. namespace Laminas\\Hydrator\\Filter; interface FilterProviderInterface { /** * Provides a filter for hydration * * @return FilterInterface */ public function getFilter(); } (The getFilter() method is automatically excluded from extract() .) If the extracted object implements the Laminas\\Hydrator\\Filter\\FilterProviderInterface , the returned FilterInterface instance can also be a FilterComposite . For example: Class Foo implements FilterProviderInterface { public function getFoo() { return 'foo'; } public function hasFoo() { return true; } public function getServiceManager() { return 'servicemanager'; } public function getEventManager() { return 'eventmanager'; } public function getFilter() { $composite = new FilterComposite(); $composite-&gt;addFilter('get', new GetFilter()); $exclusionComposite = new FilterComposite(); $exclusionComposite-&gt;addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $exclusionComposite-&gt;addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $composite-&gt;addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND); return $composite; } } $hydrator = new ClassMethodsHydrator(false); $extractedArray = $hydrator-&gt;extract(new Foo()); $extractedArray will only have 'foo' =&gt; 'foo'; all other values are excluded from extraction.","title":"Using the provider interface"},{"location":"v4/filter/#filter-enabled-hydrators-and-the-composite-filter","text":"Hydrators can indicate they are filter-enabled by implementing Laminas\\Hydrator\\Filter\\FilterEnabledInterface : namespace Laminas\\Hydrator\\Filter; interface FilterEnabledInterface extends FilterProviderInterface { /** * Add a new filter to take care of what needs to be hydrated. * To exclude e.g. the method getServiceLocator: * * &lt;code&gt; * $composite-&gt;addFilter( * \"servicelocator\", * function ($property) { * [$class, $method] = explode('::', $property, 2); * return $method !== 'getServiceLocator'; * }, * FilterComposite::CONDITION_AND * ); * &lt;/code&gt; * * @param string $name Index in the composite * @param callable|FilterInterface $filter */ public function addFilter(string $name, $filter, int $condition = FilterComposite::CONDITION_OR) : void; /** * Check whether a specific filter exists at key $name or not * * @param string $name Index in the composite */ public function hasFilter(string $name) : bool; /** * Remove a filter from the composition. * * To not extract \"has\" methods, you simply need to unregister it * * &lt;code&gt; * $filterComposite-&gt;removeFilter('has'); * &lt;/code&gt; */ public function removeFilter(string $name) : void; } Note that the interface extends FilterProviderInterface , which means it also includes the getFilter() method. The FilterEnabledInterface makes the assumption that the class will be backed by a Laminas\\Hydrator\\Filter\\FilterComposite ; the various addFilter() , hasFilter() , and removeFilter() methods are expected to proxy to a FilterComposite instance. AbstractHydrator , on which all the hydrators shipped in this package are built, implements FilterEnabledInterface . Of the hydrators shipped, only one, ClassMethodsHydrator , defines any filters from the outset. Its constructor includes the following: $this-&gt;filterComposite-&gt;addFilter('is', new IsFilter()); $this-&gt;filterComposite-&gt;addFilter('has', new HasFilter()); $this-&gt;filterComposite-&gt;addFilter('get', new GetFilter()); $this-&gt;filterComposite-&gt;addFilter( 'parameter', new NumberOfParameterFilter(), FilterComposite::CONDITION_AND );","title":"Filter-enabled hydrators and the composite filter"},{"location":"v4/migration/","text":"Migration from Version 3 This document details changes made between version 3 and version 4 that could affect end-users. Interface Changes The Laminas\\Hydrator\\Filter\\FilterInterface::filter() method changed signature to accept an optional second argument: namespace Laminas\\Hydrator\\Filter; interface FilterInterface { public function filter(string $property, ?object $instance = null) : bool; } The primary use case for this is when using anonymous objects, to facilitate reflection; the ClassMethodsHydrator , for instance, was updated to pass the $instance value only when an anonymous object is detected. All filter implementations have been updated to the new signature. Filter Changes All filters implementing Laminas\\Hydrator\\Filter\\FilterInterface shipped with the package are now marked final. If you were previously extending these classes, you will need to copy and paste the implementations; if you feel there is a general-purpose use case for extending the class, please open a feature request to remove the final keyword on the specific implementation you are interested in.","title":"Migration"},{"location":"v4/migration/#migration-from-version-3","text":"This document details changes made between version 3 and version 4 that could affect end-users.","title":"Migration from Version 3"},{"location":"v4/migration/#interface-changes","text":"The Laminas\\Hydrator\\Filter\\FilterInterface::filter() method changed signature to accept an optional second argument: namespace Laminas\\Hydrator\\Filter; interface FilterInterface { public function filter(string $property, ?object $instance = null) : bool; } The primary use case for this is when using anonymous objects, to facilitate reflection; the ClassMethodsHydrator , for instance, was updated to pass the $instance value only when an anonymous object is detected. All filter implementations have been updated to the new signature.","title":"Interface Changes"},{"location":"v4/migration/#filter-changes","text":"All filters implementing Laminas\\Hydrator\\Filter\\FilterInterface shipped with the package are now marked final. If you were previously extending these classes, you will need to copy and paste the implementations; if you feel there is a general-purpose use case for extending the class, please open a feature request to remove the final keyword on the specific implementation you are interested in.","title":"Filter Changes"},{"location":"v4/plugin-managers/","text":"Plugin Managers It can be useful to compose a plugin manager from which you can retrieve hydrators; in fact, Laminas\\Hydrator\\DelegatingHydrator does exactly that! With such a manager, you can retrieve instances using short names, or instances that have dependencies on other services, without needing to know the details of how that works. Examples of Hydrator plugin managers in real-world scenarios include: hydrating database result sets preparing API payloads HydratorPluginManagerInterface We provide two plugin manager implementations. Essentially, they only need to implement the PSR-11 ContainerInterface , but plugin managers in current versions of laminas-servicemanager only implement it indirectly via the container-interop project. As such, we ship Laminas\\Hydrator\\HydratorPluginManagerInterface , which simply extends the PSR-11 Psr\\Container\\ContainerInterface . Each of our implementations implement it. HydratorPluginManager If you have used laminas-hydrator prior to version 3, you are likely already familiar with this class, as it has been the implementation we have shipped from initial versions. The HydratorPluginManager extends the laminas-servicemanager AbstractPluginManager , and has the following behaviors: It will only return Laminas\\Hydrator\\HydratorInterface instances. It defines short-name aliases for all shipped hydrators (the class name minus the namespace), in a variety of casing combinations. All but the DelegatingHydrator are defined as invokable services (meaning they can be instantiated without any constructor arguments). The DelegatingHydrator is configured as a factory-based service, mapping to the Laminas\\Hydrator\\DelegatingHydratorFactory . No services are shared; a new instance is created each time you call get() . HydratorPluginManagerFactory Laminas\\Hydrator\\HydratorPluginManager is mapped to the factory Laminas\\Hydrator\\HydratorPluginManagerFactory when wired to the dependency injection container. The factory will look for the config service, and use the hydrators configuration key to seed it with additional services. This configuration key should map to an array that follows standard laminas-servicemanager configuration . StandaloneHydratorPluginManager Laminas\\Hydrator\\StandaloneHydratorPluginManager provides an implementation that has no dependencies on other libraries. It can only load the hydrators shipped with laminas-hydrator . StandardHydratorPluginManagerFactory Laminas\\Hydrator\\StandardHydratorPluginManager is mapped to the factory Laminas\\Hydrator\\StandardHydratorPluginManagerFactory when wired to the dependency injection container. HydratorManager alias Laminas\\Hydrator\\ConfigManager defines an alias service, HydratorManager . That service will point to Laminas\\Hydrator\\HydratorPluginManager if laminas-servicemanager is installed, and Laminas\\Hydrator\\StandaloneHydratorPluginManager otherwise. Custom plugin managers If you do not want to use laminas-servicemanager, but want a plugin manager that is customizable, or at least capable of loading the hydrators you have defined for your application, you should write a custom implementation of Laminas\\Hydrator\\HydratorPluginManagerInterface , and wire it to the HydratorManager service, and/or one of the existing service names. As an example, if you want a configurable solution that uses factories, and want those factories capable of pulling application-level dependencies, you might do something like the following: Create a custom plugin manager class, e.g. src/YourApplication/CustomHydratorPluginManager.php : namespace YourApplication; use Psr\\Container\\NotFoundExceptionInterface; use Psr\\Container\\ContainerInterface; use RuntimeException; use Laminas\\Hydrator\\HydratorInterface; use Laminas\\Hydrator\\HydratorPluginManagerInterface; use Laminas\\Hydrator\\StandaloneHydratorPluginManager; class CustomHydratorPluginManager implements HydratorPluginManagerInterface { /** @var ContainerInterface */ private $appContainer; /** @var StandaloneHydratorPluginManager */ private $defaults; /** @var array&lt;string, string|callable&gt; */ private $factories = []; public function __construct(ContainerInterface $appContainer) { $this-&gt;appContainer = $appContainer; $this-&gt;defaults = new StandaloneHydratorPluginManager(); } /** * {@inheritDoc} */ public function get($id) : HydratorInterface { if (! isset($this-&gt;factories[$id]) &amp;&amp; ! $this-&gt;defaults-&gt;has($id)) { $message = sprintf('Hydrator service %s not found', $id); throw new class($message) extends RuntimeException implements NotFoundExceptionInterface {}; } // Default was requested; fallback to standalone container if (! isset($this-&gt;factories[$id])) { return $this-&gt;defaults-&gt;get($id); } $factory = $this-&gt;factories[$id]; if (is_string($factory)) { $this-&gt;factories[$id] = $factory = new $factory(); } return $factory($this-&gt;appContainer, $id); } public function has($id) : bool { return isset($this-&gt;factories[$id]) || $this-&gt;defaults-&gt;has($id); } public function setFactoryClass(string $name, string $factory) : void { $this-&gt;factories[$name] = $factory; } public function setFactory(string $name, callable $factory) : void { $this-&gt;factories[$name] = $factory; } } Create a factory for the custom plugin manager, e.g. src/YourApplication/CustomHydratorPluginManagerFactory.php : namespace YourApplication; use Psr\\Container\\ContainerInterface; class CustomHydratorPluginManagerFactory { public function __invoke(ContainerInterface $container) : CustomHydratorPluginManager { $config = $container-&gt;has('config') ? $container-&gt;get('config') : []; $config = $config['hydrators']['factories'] ?? []; $manager = new CustomHydratorPluginManager($this); if ([] !== $config) { $this-&gt;configureManager($manager, $config); } return $manager; } /** * @param array&lt;string, string|callable&gt; $config */ private function configureManager(CustomHydratorPluginManager $manager, array $config) : void { foreach ($config as $name =&gt; $factory) { is_string($factory) ? $manager-&gt;setFactoryClass($name, $factory) : $manager-&gt;setFactory($name, $factory); } } } Register the custom plugin manager in the application configuration, e.g. config/autoload/hydrators.global.php : return [ 'dependencies' =&gt; [ 'aliases' =&gt; [ 'HydratorManager' =&gt; \\YourApplication\\CustomHydratorPluginManager::class, ], 'factories' =&gt; [ \\YourApplication\\CustomHydratorPluginManager::class =&gt; \\YourApplication\\CustomHydratorPluginManagerFactory::class ], ], 'hydrators' =&gt; [ 'factories' =&gt; [ \\Blog\\PostHydrator::class =&gt; \\Blog\\PostHydratorFactory::class, \\News\\ItemHydrator::class =&gt; \\News\\ItemHydratorFactory::class, // etc. ], ], ];","title":"Plugin Managers"},{"location":"v4/plugin-managers/#plugin-managers","text":"It can be useful to compose a plugin manager from which you can retrieve hydrators; in fact, Laminas\\Hydrator\\DelegatingHydrator does exactly that! With such a manager, you can retrieve instances using short names, or instances that have dependencies on other services, without needing to know the details of how that works. Examples of Hydrator plugin managers in real-world scenarios include: hydrating database result sets preparing API payloads","title":"Plugin Managers"},{"location":"v4/plugin-managers/#hydratorpluginmanagerinterface","text":"We provide two plugin manager implementations. Essentially, they only need to implement the PSR-11 ContainerInterface , but plugin managers in current versions of laminas-servicemanager only implement it indirectly via the container-interop project. As such, we ship Laminas\\Hydrator\\HydratorPluginManagerInterface , which simply extends the PSR-11 Psr\\Container\\ContainerInterface . Each of our implementations implement it.","title":"HydratorPluginManagerInterface"},{"location":"v4/plugin-managers/#hydratorpluginmanager","text":"If you have used laminas-hydrator prior to version 3, you are likely already familiar with this class, as it has been the implementation we have shipped from initial versions. The HydratorPluginManager extends the laminas-servicemanager AbstractPluginManager , and has the following behaviors: It will only return Laminas\\Hydrator\\HydratorInterface instances. It defines short-name aliases for all shipped hydrators (the class name minus the namespace), in a variety of casing combinations. All but the DelegatingHydrator are defined as invokable services (meaning they can be instantiated without any constructor arguments). The DelegatingHydrator is configured as a factory-based service, mapping to the Laminas\\Hydrator\\DelegatingHydratorFactory . No services are shared; a new instance is created each time you call get() .","title":"HydratorPluginManager"},{"location":"v4/plugin-managers/#standalonehydratorpluginmanager","text":"Laminas\\Hydrator\\StandaloneHydratorPluginManager provides an implementation that has no dependencies on other libraries. It can only load the hydrators shipped with laminas-hydrator .","title":"StandaloneHydratorPluginManager"},{"location":"v4/plugin-managers/#hydratormanager-alias","text":"Laminas\\Hydrator\\ConfigManager defines an alias service, HydratorManager . That service will point to Laminas\\Hydrator\\HydratorPluginManager if laminas-servicemanager is installed, and Laminas\\Hydrator\\StandaloneHydratorPluginManager otherwise.","title":"HydratorManager alias"},{"location":"v4/plugin-managers/#custom-plugin-managers","text":"If you do not want to use laminas-servicemanager, but want a plugin manager that is customizable, or at least capable of loading the hydrators you have defined for your application, you should write a custom implementation of Laminas\\Hydrator\\HydratorPluginManagerInterface , and wire it to the HydratorManager service, and/or one of the existing service names. As an example, if you want a configurable solution that uses factories, and want those factories capable of pulling application-level dependencies, you might do something like the following: Create a custom plugin manager class, e.g. src/YourApplication/CustomHydratorPluginManager.php : namespace YourApplication; use Psr\\Container\\NotFoundExceptionInterface; use Psr\\Container\\ContainerInterface; use RuntimeException; use Laminas\\Hydrator\\HydratorInterface; use Laminas\\Hydrator\\HydratorPluginManagerInterface; use Laminas\\Hydrator\\StandaloneHydratorPluginManager; class CustomHydratorPluginManager implements HydratorPluginManagerInterface { /** @var ContainerInterface */ private $appContainer; /** @var StandaloneHydratorPluginManager */ private $defaults; /** @var array&lt;string, string|callable&gt; */ private $factories = []; public function __construct(ContainerInterface $appContainer) { $this-&gt;appContainer = $appContainer; $this-&gt;defaults = new StandaloneHydratorPluginManager(); } /** * {@inheritDoc} */ public function get($id) : HydratorInterface { if (! isset($this-&gt;factories[$id]) &amp;&amp; ! $this-&gt;defaults-&gt;has($id)) { $message = sprintf('Hydrator service %s not found', $id); throw new class($message) extends RuntimeException implements NotFoundExceptionInterface {}; } // Default was requested; fallback to standalone container if (! isset($this-&gt;factories[$id])) { return $this-&gt;defaults-&gt;get($id); } $factory = $this-&gt;factories[$id]; if (is_string($factory)) { $this-&gt;factories[$id] = $factory = new $factory(); } return $factory($this-&gt;appContainer, $id); } public function has($id) : bool { return isset($this-&gt;factories[$id]) || $this-&gt;defaults-&gt;has($id); } public function setFactoryClass(string $name, string $factory) : void { $this-&gt;factories[$name] = $factory; } public function setFactory(string $name, callable $factory) : void { $this-&gt;factories[$name] = $factory; } } Create a factory for the custom plugin manager, e.g. src/YourApplication/CustomHydratorPluginManagerFactory.php : namespace YourApplication; use Psr\\Container\\ContainerInterface; class CustomHydratorPluginManagerFactory { public function __invoke(ContainerInterface $container) : CustomHydratorPluginManager { $config = $container-&gt;has('config') ? $container-&gt;get('config') : []; $config = $config['hydrators']['factories'] ?? []; $manager = new CustomHydratorPluginManager($this); if ([] !== $config) { $this-&gt;configureManager($manager, $config); } return $manager; } /** * @param array&lt;string, string|callable&gt; $config */ private function configureManager(CustomHydratorPluginManager $manager, array $config) : void { foreach ($config as $name =&gt; $factory) { is_string($factory) ? $manager-&gt;setFactoryClass($name, $factory) : $manager-&gt;setFactory($name, $factory); } } } Register the custom plugin manager in the application configuration, e.g. config/autoload/hydrators.global.php : return [ 'dependencies' =&gt; [ 'aliases' =&gt; [ 'HydratorManager' =&gt; \\YourApplication\\CustomHydratorPluginManager::class, ], 'factories' =&gt; [ \\YourApplication\\CustomHydratorPluginManager::class =&gt; \\YourApplication\\CustomHydratorPluginManagerFactory::class ], ], 'hydrators' =&gt; [ 'factories' =&gt; [ \\Blog\\PostHydrator::class =&gt; \\Blog\\PostHydratorFactory::class, \\News\\ItemHydrator::class =&gt; \\News\\ItemHydratorFactory::class, // etc. ], ], ];","title":"Custom plugin managers"},{"location":"v4/quick-start/","text":"Quick Start The laminas-hydrator component provides functionality for hydrating objects (which is the act of populating an object from a set of data) and extracting data from them. The component contains concrete implementations for a number of common use cases, such as by using arrays, object methods, and reflection, and provides interfaces for creating custom implementations. Basic Usage Hydrating an Object To hydrate an object with data, instantiate the hydrator and then pass to it the data for hydrating the object. $hydrator = new Laminas\\Hydrator\\ArraySerializableHydrator(); $data = [ 'first_name' =&gt; 'James', 'last_name' =&gt; 'Kahn', 'email_address' =&gt; 'james.kahn@example.org', 'phone_number' =&gt; '+61 419 1234 5678', ]; $object = $hydrator-&gt;hydrate($data, new ArrayObject()); Extracting Values From an Object To extract data from an object, instantiate the applicable hydrator and then call extract , passing to it the object to extract data from. $hydrator = new Laminas\\Hydrator\\ArraySerializableHydrator(); // ... Assuming that $object has already been initialised $data = $hydrator-&gt;extract($object); Available Implementations ArraySerializableHydrator The ArraySerializableHydrator hydrates data from an array and extracts an object’s data returning it as an array. Objects passed to the hydrate method must implement either exchangeArray() or populate() to support hydration, and must implement getArrayCopy() to support extraction. ClassMethodsHydrator The ClassMethodsHydrator calls \"setter\" methods matching keys in the data set to hydrate objects and calls \"getter\" methods matching keys in the data set during extraction, based on the following rules: is*() , has*() , and get*() methods will be used when extracting data. The method prefix will be removed from the key's name. set*() methods will be used when hydrating properties. class User { private $firstName; private $lastName; private $emailAddress; private $phoneNumber; public function setFirstName(string $firstName) { $this-&gt;firstName = $firstName; } public function setLastName(string $lastName) { $this-&gt;lastName = $lastName; } public function setEmailAddress(string $emailAddress) { $this-&gt;emailAddress = $emailAddress; } public function setPhoneNumber(string $phoneNumber) { $this-&gt;phoneNumber = $phoneNumber; } } $data = [ 'first_name' =&gt; 'James', 'last_name' =&gt; 'Kahn', 'email_address' =&gt; 'james.kahn@example.org', 'phone_number' =&gt; '+61 419 1234 5678', ]; $hydrator = new Laminas\\Hydrator\\ClassMethodsHydrator(); $user = $hydrator-&gt;hydrate($data, new User()); $data = $hydrator-&gt;extract(new User()); ObjectPropertyHydrator The ObjectPropertyHydrator hydrates objects and extracts data using publicly accessible properties which match a key in the data set. class User { public $firstName; public $lastName; public $emailAddress; public $phoneNumber; } $data = [ 'first_name' =&gt; 'James', 'last_name' =&gt; 'Kahn', 'email_address' =&gt; 'james.kahn@example.org', 'phone_number' =&gt; '+61 419 1234 5678', ]; $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $user = $hydrator-&gt;hydrate($data, new User()); $data = $hydrator-&gt;extract(new User()); ReflectionHydrator The ReflectionHydrator is similar to the ObjectPropertyHydrator , however it uses PHP's reflection API to hydrate or extract properties of any visibility. Any data key matching an existing property will be hydrated. Any existing properties will be used for extracting data. class User { private $firstName; private $lastName; private $emailAddress; private $phoneNumber; } $data = [ 'first_name' =&gt; 'James', 'last_name' =&gt; 'Kahn', 'email_address' =&gt; 'james.kahn@example.org', 'phone_number' =&gt; '+61 419 1234 5678', ]; $hydrator = new Laminas\\Hydrator\\ReflectionHydrator(); $user = $hydrator-&gt;hydrate($data, new User()); $data = $hydrator-&gt;extract(new User()); DelegatingHydrator The DelegatingHydrator composes a hydrator locator, and will delegate hydrate() and extract() calls to the appropriate one based upon the class name of the object being operated on. // Instantiate each hydrator you wish to delegate to $albumHydrator = new Laminas\\Hydrator\\ClassMethodsHydrator(); $artistHydrator = new Laminas\\Hydrator\\ClassMethodsHydrator(); // Map the entity class name to the hydrator using the HydratorPluginManager. // In this case we have two entity classes, \"Album\" and \"Artist\". $hydrators = new Laminas\\Hydrator\\HydratorPluginManager; $hydrators-&gt;setService('Album', $albumHydrator); $hydrators-&gt;setService('Artist', $artistHydrator); // Create the DelegatingHydrator and tell it to use our configured hydrator locator $delegating = new Laminas\\Hydrator\\DelegatingHydrator($hydrators); // Now we can use $delegating to hydrate or extract any supported object // Assumes that $data and Artist have already been initialised $array = $delegating-&gt;extract(new Artist()); $artist = $delegating-&gt;hydrate($data, new Artist());","title":"Quick Start"},{"location":"v4/quick-start/#quick-start","text":"The laminas-hydrator component provides functionality for hydrating objects (which is the act of populating an object from a set of data) and extracting data from them. The component contains concrete implementations for a number of common use cases, such as by using arrays, object methods, and reflection, and provides interfaces for creating custom implementations.","title":"Quick Start"},{"location":"v4/quick-start/#basic-usage","text":"","title":"Basic Usage"},{"location":"v4/quick-start/#available-implementations","text":"","title":"Available Implementations"},{"location":"v4/strategy/","text":"Introduction You can compose Laminas\\Hydrator\\Strategy\\StrategyInterface instances in any of the hydrators to manipulate the way they behave on extract() and hydrate() for specific key/value pairs. The interface offers the following definitions: namespace Laminas\\Hydrator\\Strategy; interface StrategyInterface { /** * Converts the given value so that it can be extracted by the hydrator. * * @param mixed $value The original value. * @param null|object $object (optional) The original object for context. * @return mixed Returns the value that should be extracted. */ public function extract($value, ?object $object = null); /** * Converts the given value so that it can be hydrated by the hydrator. * * @param mixed $value The original value. * @param null|array $data (optional) The original data for context. * @return mixed Returns the value that should be hydrated. */ public function hydrate($value, ?array $data = null); } This interface is similar to what the Laminas\\Hydrator\\ExtractionInterface and Laminas\\Hydrator\\HydrationInterface provide; the reason is that strategies provide a proxy implementation for hydrate() and extract() on individual values. For this reason, their return types are listed as mixed, versus as array and object , respectively. Adding strategies to the hydrators This package provides the interface Laminas\\Hydrator\\Strategy\\StrategyEnabledInterface . Hydrators can implement this interface, and then call on its getStrategy() method in order to extract or hydrate individual values. The interface has the following definition: namespace Laminas\\Hydrator\\Strategy; interface StrategyEnabledInterface { /** * Adds the given strategy under the given name. */ public function addStrategy(string $name, StrategyInterface $strategy) : void; /** * Gets the strategy with the given name. */ public function getStrategy(string $name) : StrategyInterface; /** * Checks if the strategy with the given name exists. */ public function hasStrategy(string $name) : bool; /** * Removes the strategy with the given name. */ public function removeStrategy(string $name) : void; } We provide a default implementation of the interface as part of Laminas\\Hydrator\\AbstractHydrator ; it uses an array property to store and retrieve strategies by name when extracting and hydrating values. Since all shipped hydrators are based on AbstractHydrator , they share these capabilities. Additionally, the functionality that consumes strategies within AbstractHydrator also contains checks if a naming strategy is composed, and, if present, will use it to translate the property name prior to looking up a strategy for it. Available implementations Laminas\\Hydrator\\Strategy\\BooleanStrategy This strategy converts values into booleans and vice versa. It expects two arguments at the constructor, which are used to define value maps for true and false . The arguments could be strings: $boolStrategy = new Laminas\\Hydrator\\Strategy\\BooleanStrategy('1', '0'); or integers: $boolStrategy = new Laminas\\Hydrator\\Strategy\\BooleanStrategy(1, 0); The main difference from ScalarTypeStrategy is extracting booleans back to arguments given at the constructor. Laminas\\Hydrator\\Strategy\\ClosureStrategy This is a strategy that allows you to pass in options for: hydrate , a callback to be called when hydrating a value, and extract , a callback to be called when extracting a value. Laminas\\Hydrator\\Strategy\\DateTimeFormatterStrategy DateTimeFormatterStrategy provides bidirectional conversion between strings and DateTime instances. The input and output formats can be provided as constructor arguments. The strategy allows DateTime formats that use ! to prepend the format, or | or + to append it; these ensure that, during hydration, the new DateTime instance created will set the time element accordingly. As a specific example, Y-m-d| will drop the time component, ensuring comparisons are based on a midnight time value. Starting in version 3.0, the constructor defines a third, optional argument, $dateTimeFallback . If enabled and hydration fails, the given string is parsed by the DateTime constructor, as demonstrated below: // Previous behavior: $strategy = new Laminas\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d H:i:s.uP'); $hydrated1 = $strategy-&gt;hydrate('2016-03-04 10:29:40.123456+01'); // Format is the same; returns DateTime instance $hydrated2 = $strategy-&gt;hydrate('2016-03-04 10:29:40+01'); // Format is different; value is not hydrated // Using new $dateTimeFallback flag; both values are hydrated: $strategy = new Laminas\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d H:i:s.uP', null, true); $hydrated1 = $strategy-&gt;hydrate('2016-03-04 10:29:40.123456+01'); $hydrated2 = $strategy-&gt;hydrate('2016-03-04 10:29:40+01'); Laminas\\Hydrator\\Strategy\\DefaultStrategy The DefaultStrategy simply proxies everything through, without performing any conversion of values. Laminas\\Hydrator\\Strategy\\ExplodeStrategy This strategy is a wrapper around PHP's implode() and explode() functions. The delimiter and a limit can be provided to the constructor; the limit will only be used for extract operations. Laminas\\Hydrator\\Strategy\\NullableStrategy Since 4.1.0 This strategy acts as a decorator around another strategy, allowing extraction and hydration of nullable values. The constructor accepts two arguments: the strategy to decorate, and a boolean flag indicating whether or not to treat empty values as null . By default, the flag is false , indicating only null values should be treated as null . Usage of this strategy also ensures a value is extracted or hydrated when it is null , instead of being dropped from the representation. Laminas\\Hydrator\\Strategy\\ScalarTypeStrategy Available since version 4.2.0 This strategy allows extraction and hydration of the scalar types int , float , string , and bool . The constructor accepts one argument, one of the constants: Laminas\\Hydrator\\Strategy\\ScalarTypeStrategy::TYPE_INT (\"int\") Laminas\\Hydrator\\Strategy\\ScalarTypeStrategy::TYPE_FLOAT (\"float\") Laminas\\Hydrator\\Strategy\\ScalarTypeStrategy::TYPE_STRING (\"string\") Laminas\\Hydrator\\Strategy\\ScalarTypeStrategy::TYPE_BOOL (\"bool\") Alternately, you can use one of the named constructors to create the instance via the following static methods: Laminas\\Hydrator\\Strategy\\ScalarTypeStrategy::createToInt() Laminas\\Hydrator\\Strategy\\ScalarTypeStrategy::createToFloat() Laminas\\Hydrator\\Strategy\\ScalarTypeStrategy::createToString() Laminas\\Hydrator\\Strategy\\ScalarTypeStrategy::createToBoolean() In each case, calling hydrate() will cast the $value provided to it to the appropriate scalar type. Laminas\\Hydrator\\Strategy\\StrategyChain This strategy takes an array of StrategyInterface instances and iterates over them when performing extract() and hydrate() operations. Each operates on the return value of the previous, allowing complex operations based on smaller, single-purpose strategies. Writing custom strategies The following example, while not terribly useful, will provide you with the basics for writing your own strategies, as well as provide ideas as to where and when to use them. This strategy simply transforms the value for the defined key using str_rot13() during both the extract() and hydrate() operations: class Rot13Strategy implements StrategyInterface { public function extract($value) { return str_rot13($value); } public function hydrate($value) { return str_rot13($value); } } This is the example class with which we want to use the hydrator example: class Foo { protected $foo = null; protected $bar = null; public function getFoo() { return $this-&gt;foo; } public function setFoo($foo) { $this-&gt;foo = $foo; } public function getBar() { return $this-&gt;bar; } public function setBar($bar) { $this-&gt;bar = $bar; } } Now, we'll add the rot13 strategy to the method getFoo() and setFoo($foo) : $foo = new Foo(); $foo-&gt;setFoo('bar'); $foo-&gt;setBar('foo'); $hydrator = new ClassMethodsHydrator(); $hydrator-&gt;addStrategy('foo', new Rot13Strategy()); When you use the hydrator to extract an array for the object $foo , you'll receive the following: $extractedArray = $hydrator-&gt;extract($foo); // array(2) { // [\"foo\"]=&gt; // string(3) \"one\" // [\"bar\"]=&gt; // string(3) \"foo\" // } And when hydrating a new Foo instance: $hydrator-&gt;hydrate($extractedArray, $foo) // object(Foo)#2 (2) { // [\"foo\":protected]=&gt; // string(3) \"bar\" // [\"bar\":protected]=&gt; // string(3) \"foo\" // }","title":"Introduction"},{"location":"v4/strategy/#introduction","text":"You can compose Laminas\\Hydrator\\Strategy\\StrategyInterface instances in any of the hydrators to manipulate the way they behave on extract() and hydrate() for specific key/value pairs. The interface offers the following definitions: namespace Laminas\\Hydrator\\Strategy; interface StrategyInterface { /** * Converts the given value so that it can be extracted by the hydrator. * * @param mixed $value The original value. * @param null|object $object (optional) The original object for context. * @return mixed Returns the value that should be extracted. */ public function extract($value, ?object $object = null); /** * Converts the given value so that it can be hydrated by the hydrator. * * @param mixed $value The original value. * @param null|array $data (optional) The original data for context. * @return mixed Returns the value that should be hydrated. */ public function hydrate($value, ?array $data = null); } This interface is similar to what the Laminas\\Hydrator\\ExtractionInterface and Laminas\\Hydrator\\HydrationInterface provide; the reason is that strategies provide a proxy implementation for hydrate() and extract() on individual values. For this reason, their return types are listed as mixed, versus as array and object , respectively.","title":"Introduction"},{"location":"v4/strategy/#adding-strategies-to-the-hydrators","text":"This package provides the interface Laminas\\Hydrator\\Strategy\\StrategyEnabledInterface . Hydrators can implement this interface, and then call on its getStrategy() method in order to extract or hydrate individual values. The interface has the following definition: namespace Laminas\\Hydrator\\Strategy; interface StrategyEnabledInterface { /** * Adds the given strategy under the given name. */ public function addStrategy(string $name, StrategyInterface $strategy) : void; /** * Gets the strategy with the given name. */ public function getStrategy(string $name) : StrategyInterface; /** * Checks if the strategy with the given name exists. */ public function hasStrategy(string $name) : bool; /** * Removes the strategy with the given name. */ public function removeStrategy(string $name) : void; } We provide a default implementation of the interface as part of Laminas\\Hydrator\\AbstractHydrator ; it uses an array property to store and retrieve strategies by name when extracting and hydrating values. Since all shipped hydrators are based on AbstractHydrator , they share these capabilities. Additionally, the functionality that consumes strategies within AbstractHydrator also contains checks if a naming strategy is composed, and, if present, will use it to translate the property name prior to looking up a strategy for it.","title":"Adding strategies to the hydrators"},{"location":"v4/strategy/#available-implementations","text":"","title":"Available implementations"},{"location":"v4/strategy/#writing-custom-strategies","text":"The following example, while not terribly useful, will provide you with the basics for writing your own strategies, as well as provide ideas as to where and when to use them. This strategy simply transforms the value for the defined key using str_rot13() during both the extract() and hydrate() operations: class Rot13Strategy implements StrategyInterface { public function extract($value) { return str_rot13($value); } public function hydrate($value) { return str_rot13($value); } } This is the example class with which we want to use the hydrator example: class Foo { protected $foo = null; protected $bar = null; public function getFoo() { return $this-&gt;foo; } public function setFoo($foo) { $this-&gt;foo = $foo; } public function getBar() { return $this-&gt;bar; } public function setBar($bar) { $this-&gt;bar = $bar; } } Now, we'll add the rot13 strategy to the method getFoo() and setFoo($foo) : $foo = new Foo(); $foo-&gt;setFoo('bar'); $foo-&gt;setBar('foo'); $hydrator = new ClassMethodsHydrator(); $hydrator-&gt;addStrategy('foo', new Rot13Strategy()); When you use the hydrator to extract an array for the object $foo , you'll receive the following: $extractedArray = $hydrator-&gt;extract($foo); // array(2) { // [\"foo\"]=&gt; // string(3) \"one\" // [\"bar\"]=&gt; // string(3) \"foo\" // } And when hydrating a new Foo instance: $hydrator-&gt;hydrate($extractedArray, $foo) // object(Foo)#2 (2) { // [\"foo\":protected]=&gt; // string(3) \"bar\" // [\"bar\":protected]=&gt; // string(3) \"foo\" // }","title":"Writing custom strategies"},{"location":"v4/naming-strategy/composite-naming-strategy/","text":"CompositeNamingStrategy Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy allows you to specify which naming strategy should be used for each key encountered during hydration or extraction. Basic Usage When invoked, the following composite strategy will extract the property bar to the array key foo (using the MapNamingStrategy ), and the property barBat to the array key bar_bat (using the UnderscoreNamingStrategy ): class Foo { public $bar; public $barBat; } $mapStrategy = Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap([ 'foo' =&gt; 'bar' ]); $underscoreNamingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ 'bar' =&gt; $mapStrategy, 'barBat' =&gt; $underscoreNamingStrategy, ]); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $foo-&gt;bar = 123; $foo-&gt;barBat = 42; print_r($foo); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 [bar_bat] =&gt; 42 ) Unfortunately, the CompositeNamingStrategy can only be used for extraction as it will not know how to handle the keys necessary for hydration ( foo and bar_bat , respectively). To rectify this we have to cover the keys for both hydration and extraction in our composite strategy: class Foo { public $bar; public $barBat; } $mapStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' =&gt; 'bar' ]); $underscoreNamingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ // Define both directions for the foo =&gt; bar mapping 'bar' =&gt; $mapStrategy, 'foo' =&gt; $mapStrategy, // Define both directions for the barBat =&gt; bar_bat mapping 'barBat' =&gt; $underscoreNamingStrategy, 'bar_bat' =&gt; $underscoreNamingStrategy, ]); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $foo-&gt;bar = 123; $foo-&gt;barBat = 42; $array = $hydrator-&gt;extract($foo); print_r($foo); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 ) print_r($array); // Array ( [foo] =&gt; 123 [bar_bat] =&gt; 42 ) $foo2 = new Foo(); $hydrator-&gt;hydrate($array, $foo2); print_r($foo2); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 )","title":"Composite"},{"location":"v4/naming-strategy/composite-naming-strategy/#compositenamingstrategy","text":"Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy allows you to specify which naming strategy should be used for each key encountered during hydration or extraction.","title":"CompositeNamingStrategy"},{"location":"v4/naming-strategy/composite-naming-strategy/#basic-usage","text":"When invoked, the following composite strategy will extract the property bar to the array key foo (using the MapNamingStrategy ), and the property barBat to the array key bar_bat (using the UnderscoreNamingStrategy ): class Foo { public $bar; public $barBat; } $mapStrategy = Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap([ 'foo' =&gt; 'bar' ]); $underscoreNamingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ 'bar' =&gt; $mapStrategy, 'barBat' =&gt; $underscoreNamingStrategy, ]); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $foo-&gt;bar = 123; $foo-&gt;barBat = 42; print_r($foo); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 [bar_bat] =&gt; 42 ) Unfortunately, the CompositeNamingStrategy can only be used for extraction as it will not know how to handle the keys necessary for hydration ( foo and bar_bat , respectively). To rectify this we have to cover the keys for both hydration and extraction in our composite strategy: class Foo { public $bar; public $barBat; } $mapStrategy = new Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' =&gt; 'bar' ]); $underscoreNamingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ // Define both directions for the foo =&gt; bar mapping 'bar' =&gt; $mapStrategy, 'foo' =&gt; $mapStrategy, // Define both directions for the barBat =&gt; bar_bat mapping 'barBat' =&gt; $underscoreNamingStrategy, 'bar_bat' =&gt; $underscoreNamingStrategy, ]); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $foo-&gt;bar = 123; $foo-&gt;barBat = 42; $array = $hydrator-&gt;extract($foo); print_r($foo); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 ) print_r($array); // Array ( [foo] =&gt; 123 [bar_bat] =&gt; 42 ) $foo2 = new Foo(); $hydrator-&gt;hydrate($array, $foo2); print_r($foo2); // Foo Object ( [bar] =&gt; 123 [barBat] =&gt; 42 )","title":"Basic Usage"},{"location":"v4/naming-strategy/identity-naming-strategy/","text":"IdentityNamingStrategy Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy uses the keys provided to it for hydration and extraction. Basic Usage $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); echo $namingStrategy-&gt;hydrate('foo'); // outputs: foo echo $namingStrategy-&gt;extract('bar'); // outputs: bar This strategy can be used in hydrators as well: class Foo { public $foo; } $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator-&gt;hydrate(array('foo' =&gt; 123), $foo); print_r($foo); // Foo Object ( [foo] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 )","title":"Identity"},{"location":"v4/naming-strategy/identity-naming-strategy/#identitynamingstrategy","text":"Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy uses the keys provided to it for hydration and extraction.","title":"IdentityNamingStrategy"},{"location":"v4/naming-strategy/identity-naming-strategy/#basic-usage","text":"$namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); echo $namingStrategy-&gt;hydrate('foo'); // outputs: foo echo $namingStrategy-&gt;extract('bar'); // outputs: bar This strategy can be used in hydrators as well: class Foo { public $foo; } $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator-&gt;hydrate(array('foo' =&gt; 123), $foo); print_r($foo); // Foo Object ( [foo] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo] =&gt; 123 )","title":"Basic Usage"},{"location":"v4/naming-strategy/intro/","text":"Naming Strategies Sometimes, the representation of a property should not share the same name as the property itself. As an example, when serializing an object for a JSON payload, you may want to convert camelCase properties to underscore_separated properties, and vice versa when deserializing JSON to an object. To make that possible, laminas-hydrator provides naming strategies . These are similar to strategies , but instead of operating on the value , they operate on the name . NamingStrategyInterface Naming strategies implement Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface : namespace Laminas\\Hydrator\\NamingStrategy; /** * Allow property extraction / hydration for hydrator */ interface NamingStrategyInterface { /** * Converts the given name so that it can be extracted by the hydrator. * * @param null|mixed[] $data The original data for context. */ public function hydrate(string $name, ?array $data = null) : string; /** * Converts the given name so that it can be hydrated by the hydrator. * * @param null|object $object The original object for context. */ public function extract(string $name, ?object $object = null) : string; } Providing naming strategies Hydrators can indicate they will consume naming strategies, as well as allow registration of them, by implementing Laminas\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface : namespace Laminas\\Hydrator\\NamingStrategy; interface NamingStrategyEnabledInterface { /** * Sets the naming strategy. */ public function setNamingStrategy(NamingStrategyInterface $strategy) : void; /** * Gets the naming strategy. */ public function getNamingStrategy() : NamingStrategyInterface; /** * Checks if a naming strategy exists. */ public function hasNamingStrategy() : bool; /** * Removes the naming strategy. */ public function removeNamingStrategy() : void; } We provide a default implementation of this interface within the Laminas\\Hydrator\\AbstractHydrator definition. Its getNamingStrategy() will lazy-load an IdentityNamingStrategy if none has been previously registered. Since all shipped hydrators extend AbstractHydrator , they can consume naming strategies. Shipped naming strategies We provide the following naming strategies: CompositeNamingStrategy IdentityNamingStrategy MapNamingStrategy UnderscoreNamingStrategy","title":"Introduction"},{"location":"v4/naming-strategy/intro/#naming-strategies","text":"Sometimes, the representation of a property should not share the same name as the property itself. As an example, when serializing an object for a JSON payload, you may want to convert camelCase properties to underscore_separated properties, and vice versa when deserializing JSON to an object. To make that possible, laminas-hydrator provides naming strategies . These are similar to strategies , but instead of operating on the value , they operate on the name .","title":"Naming Strategies"},{"location":"v4/naming-strategy/intro/#namingstrategyinterface","text":"Naming strategies implement Laminas\\Hydrator\\NamingStrategy\\NamingStrategyInterface : namespace Laminas\\Hydrator\\NamingStrategy; /** * Allow property extraction / hydration for hydrator */ interface NamingStrategyInterface { /** * Converts the given name so that it can be extracted by the hydrator. * * @param null|mixed[] $data The original data for context. */ public function hydrate(string $name, ?array $data = null) : string; /** * Converts the given name so that it can be hydrated by the hydrator. * * @param null|object $object The original object for context. */ public function extract(string $name, ?object $object = null) : string; }","title":"NamingStrategyInterface"},{"location":"v4/naming-strategy/intro/#providing-naming-strategies","text":"Hydrators can indicate they will consume naming strategies, as well as allow registration of them, by implementing Laminas\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface : namespace Laminas\\Hydrator\\NamingStrategy; interface NamingStrategyEnabledInterface { /** * Sets the naming strategy. */ public function setNamingStrategy(NamingStrategyInterface $strategy) : void; /** * Gets the naming strategy. */ public function getNamingStrategy() : NamingStrategyInterface; /** * Checks if a naming strategy exists. */ public function hasNamingStrategy() : bool; /** * Removes the naming strategy. */ public function removeNamingStrategy() : void; } We provide a default implementation of this interface within the Laminas\\Hydrator\\AbstractHydrator definition. Its getNamingStrategy() will lazy-load an IdentityNamingStrategy if none has been previously registered. Since all shipped hydrators extend AbstractHydrator , they can consume naming strategies.","title":"Providing naming strategies"},{"location":"v4/naming-strategy/intro/#shipped-naming-strategies","text":"We provide the following naming strategies: CompositeNamingStrategy IdentityNamingStrategy MapNamingStrategy UnderscoreNamingStrategy","title":"Shipped naming strategies"},{"location":"v4/naming-strategy/map-naming-strategy/","text":"MapNamingStrategy Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy allows you to provide a map of keys to use both during extraction and hydration; the map will translate the key based on the direction: When a map is provided for hydration, but not extraction, the strategy will perform an array_flip on the hydration map when performing lookups. You can create an instance with this behavior using MapNamingStrategy::createFromHydrationMap(array $hydrationMap) : MapNamingStrategy . When a map is provided for extraction, but not hydration, the strategy will perform an array_flip on the extraction map when performing lookups. You can create an instance with this behavior using MapNamingStrategy::createFromExtractionMap(array $extractionMap) : MapNamingStrategy . When maps are provided for both extraction and hydration, the appropriate map will be used during extraction and hydration operations. You can create an instance with this behavior using MapNamingStrategy::createFromAsymmetricMap(array $extractionMap, array $hydrationStrategy) : MapNamingStrategy . Most of the time, you will want your maps symmetrical; as such, set either a hydration map or an extraction map, but not both. Creating maps Hydration map only $namingStrategy = Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap( [ 'foo' =&gt; 'bar', 'baz' =&gt; 'bash' ] ); echo $namingStrategy-&gt;extract('bar'); // outputs: foo echo $namingStrategy-&gt;extract('bash'); // outputs: baz echo $namingStrategy-&gt;hydrate('foo'); // outputs: bar echo $namingStrategy-&gt;hydrate('baz'); // outputs: bash Extraction map only $namingStrategy = Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromExtractionMap( [ 'foo' =&gt; 'bar', 'baz' =&gt; 'bash' ] ); echo $namingStrategy-&gt;extract('foo'); // outputs: bar echo $namingStrategy-&gt;extract('baz'); // outputs: bash echo $namingStrategy-&gt;hydrate('bar'); // outputs: foo echo $namingStrategy-&gt;hydrate('bash'); // outputs: baz Both hydration and extraction maps $namingStrategy = Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromAsymmetricMap( [ 'foo' =&gt; 'bar', 'baz' =&gt; 'bash' ], [ 'is_bar' =&gt; 'foo', 'bashable' =&gt; 'baz', ] ); echo $namingStrategy-&gt;extract('foo'); // outputs: bar echo $namingStrategy-&gt;extract('baz'); // outputs: bash echo $namingStrategy-&gt;hydrate('is_bar'); // outputs: foo echo $namingStrategy-&gt;hydrate('bashable'); // outputs: baz Mapping keys for hydrators This strategy can be used in hydrators to dictate how keys should be mapped: class Foo { public $bar; } $namingStrategy = Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap([ 'foo' =&gt; 'bar', 'baz' =&gt; 'bash', ]); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator-&gt;hydrate(['foo' =&gt; 123], $foo); print_r($foo); // Foo Object ( [bar] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( \"foo\" =&gt; 123 )","title":"Mapping"},{"location":"v4/naming-strategy/map-naming-strategy/#mapnamingstrategy","text":"Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy allows you to provide a map of keys to use both during extraction and hydration; the map will translate the key based on the direction: When a map is provided for hydration, but not extraction, the strategy will perform an array_flip on the hydration map when performing lookups. You can create an instance with this behavior using MapNamingStrategy::createFromHydrationMap(array $hydrationMap) : MapNamingStrategy . When a map is provided for extraction, but not hydration, the strategy will perform an array_flip on the extraction map when performing lookups. You can create an instance with this behavior using MapNamingStrategy::createFromExtractionMap(array $extractionMap) : MapNamingStrategy . When maps are provided for both extraction and hydration, the appropriate map will be used during extraction and hydration operations. You can create an instance with this behavior using MapNamingStrategy::createFromAsymmetricMap(array $extractionMap, array $hydrationStrategy) : MapNamingStrategy . Most of the time, you will want your maps symmetrical; as such, set either a hydration map or an extraction map, but not both.","title":"MapNamingStrategy"},{"location":"v4/naming-strategy/map-naming-strategy/#creating-maps","text":"","title":"Creating maps"},{"location":"v4/naming-strategy/map-naming-strategy/#mapping-keys-for-hydrators","text":"This strategy can be used in hydrators to dictate how keys should be mapped: class Foo { public $bar; } $namingStrategy = Laminas\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap([ 'foo' =&gt; 'bar', 'baz' =&gt; 'bash', ]); $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator-&gt;hydrate(['foo' =&gt; 123], $foo); print_r($foo); // Foo Object ( [bar] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( \"foo\" =&gt; 123 )","title":"Mapping keys for hydrators"},{"location":"v4/naming-strategy/underscore-naming-strategy/","text":"UnderscoreNamingStrategy Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy converts snake case strings (e.g. foo_bar_baz ) to camel-case strings (e.g. fooBarBaz ) and vice versa. Basic Usage $namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); echo $namingStrategy-&gt;extract('foo_bar'); // outputs: foo_bar echo $namingStrategy-&gt;extract('Foo_Bar'); // outputs: foo_bar echo $namingStrategy-&gt;extract('FooBar'); // outputs: foo_bar echo $namingStrategy-&gt;hydrate('fooBar'); // outputs: fooBar echo $namingStrategy-&gt;hydrate('FooBar'); // outputs: fooBar echo $namingStrategy-&gt;hydrate('Foo_Bar'); // outputs: fooBar This strategy can be used in hydrators to dictate how keys should be mapped. class Foo { public $fooBar; } $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy(new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy()); $foo = new Foo(); $hydrator-&gt;hydrate(['foo_bar' =&gt; 123], $foo); print_r($foo); // Foo Object ( [fooBar] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo_bar] =&gt; 123 )","title":"Underscore Mapping"},{"location":"v4/naming-strategy/underscore-naming-strategy/#underscorenamingstrategy","text":"Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy converts snake case strings (e.g. foo_bar_baz ) to camel-case strings (e.g. fooBarBaz ) and vice versa.","title":"UnderscoreNamingStrategy"},{"location":"v4/naming-strategy/underscore-naming-strategy/#basic-usage","text":"$namingStrategy = new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); echo $namingStrategy-&gt;extract('foo_bar'); // outputs: foo_bar echo $namingStrategy-&gt;extract('Foo_Bar'); // outputs: foo_bar echo $namingStrategy-&gt;extract('FooBar'); // outputs: foo_bar echo $namingStrategy-&gt;hydrate('fooBar'); // outputs: fooBar echo $namingStrategy-&gt;hydrate('FooBar'); // outputs: fooBar echo $namingStrategy-&gt;hydrate('Foo_Bar'); // outputs: fooBar This strategy can be used in hydrators to dictate how keys should be mapped. class Foo { public $fooBar; } $hydrator = new Laminas\\Hydrator\\ObjectPropertyHydrator(); $hydrator-&gt;setNamingStrategy(new Laminas\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy()); $foo = new Foo(); $hydrator-&gt;hydrate(['foo_bar' =&gt; 123], $foo); print_r($foo); // Foo Object ( [fooBar] =&gt; 123 ) print_r($hydrator-&gt;extract($foo)); // Array ( [foo_bar] =&gt; 123 )","title":"Basic Usage"},{"location":"v4/strategies/collection/","text":"Collection The CollectionStrategy can be used to hydrate a collection of objects with data from an array with multiple items and vice versa . The strategy uses a hydrator to hydrate and extract data from each item of a collection. Basic usage The following code example shows standalone usage without adding the strategy to a hydrator. Create and configure strategy Create the strategy and set a hydrator and a classname for the handled object items. $strategy = new Laminas\\Hydrator\\Strategy\\CollectionStrategy( new Laminas\\Hydrator\\ObjectPropertyHydrator(), stdClass::class ); Hydrate data $hydrated = $strategy-&gt;hydrate([ [ 'title' =&gt; 'Modern Love', 'duration' =&gt; '4:46', ], [ 'title' =&gt; 'China Girl', 'duration' =&gt; '5:32', ], // … ]); echo $hydrated[1]-&gt;title; // 'China Girl' echo $hydrated[1]-&gt;duration; // '5:32' Extract data // Define array with objects $track1 = new stdClass(); $track1-&gt;title = 'Modern Love'; $track1-&gt;duration = '4:46'; $track2 = new stdClass(); $track2-&gt;title = 'China Girl'; $track2-&gt;duration = '5:32'; $data = [ $track1, $track2, ]; // Extract $extracted = $strategy-&gt;extract($data); var_dump($extracted); /* array(2) { [0] =&gt; array(2) { 'title' =&gt; string(11) \"Modern Love\" 'duration' =&gt; string(4) \"4:46\" } [1] =&gt; array(2) { 'title' =&gt; string(10) \"China Girl\" 'duration' =&gt; string(4) \"5:32\" } } */ Example The following example shows the hydration for a class with a property that consumes array of classes. An example class which represents a music album with tracks. class Album { private ?string $title; private ?string $artist; private array $tracks; public function __construct( ?string $title = null, ?string $artist = null, array $tracks = [] ) { $this-&gt;title = $title; $this-&gt;artist = $artist; $this-&gt;tracks = $tracks; } public function getTitle() : ?string { return $this-&gt;title; } public function getArtist() : ?string { return $this-&gt;artist; } public function getTracks() : array { return $this-&gt;tracks; } } An example class representing a track of an album. class Track { private ?string $title; private ?string $duration; public function __construct( ?string $title = null, ?string $duration = null ) { $this-&gt;title = $title; $this-&gt;duration = $duration; } public function getTitle() : ?string { return $this-&gt;title; } public function getDuration() : ?string { return $this-&gt;duration; } } Create hydrator and add strategy Create a hydrator and add CollectionStrategy as a strategy, with a hydrator and a classname for the handled object items. $hydrator = new Laminas\\Hydrator\\ReflectionHydrator(); $hydrator-&gt;addStrategy( 'tracks', new Laminas\\Hydrator\\Strategy\\CollectionStrategy( new Laminas\\Hydrator\\ReflectionHydrator(), Track::class ) ); Hydrate data Create an instance of the example Album class and hydrate data. $album = new Album(); $hydrator-&gt;hydrate( [ 'artist' =&gt; 'David Bowie', 'title' =&gt; 'Let\\'s Dance', 'tracks' =&gt; [ [ 'title' =&gt; 'Modern Love', 'duration' =&gt; '4:46', ], [ 'title' =&gt; 'China Girl', 'duration' =&gt; '5:32', ], [ 'title' =&gt; 'Let\\'s Dance', 'duration' =&gt; '7:38', ], // … ], ], $album ); echo $album-&gt;getTitle(); // \"Let's Dance\" echo $album-&gt;getArtist(); // 'David Bowie' echo $album-&gt;getTracks()[1]-&gt;getTitle(); // 'China Girl' echo $album-&gt;getTracks()[1]-&gt;getDuration(); // '5:32' Extract data var_dump($hydrator-&gt;extract($album)); /* array(3) { 'title' =&gt; string(11) \"Let's Dance\" 'artist' =&gt; string(11) \"David Bowie\" 'tracks' =&gt; array(3) { [0] =&gt; array(2) { 'title' =&gt; string(11) \"Modern Love\" 'duration' =&gt; string(4) \"4:46\" } [1] =&gt; array(2) { 'title' =&gt; string(10) \"China Girl\" 'duration' =&gt; string(4) \"5:32\" } [2] =&gt; array(2) { 'title' =&gt; string(11) \"Let's Dance\" 'duration' =&gt; string(4) \"7:38\" } } } */","title":"Collection"},{"location":"v4/strategies/collection/#collection","text":"The CollectionStrategy can be used to hydrate a collection of objects with data from an array with multiple items and vice versa . The strategy uses a hydrator to hydrate and extract data from each item of a collection.","title":"Collection"},{"location":"v4/strategies/collection/#basic-usage","text":"The following code example shows standalone usage without adding the strategy to a hydrator.","title":"Basic usage"},{"location":"v4/strategies/collection/#example","text":"The following example shows the hydration for a class with a property that consumes array of classes. An example class which represents a music album with tracks. class Album { private ?string $title; private ?string $artist; private array $tracks; public function __construct( ?string $title = null, ?string $artist = null, array $tracks = [] ) { $this-&gt;title = $title; $this-&gt;artist = $artist; $this-&gt;tracks = $tracks; } public function getTitle() : ?string { return $this-&gt;title; } public function getArtist() : ?string { return $this-&gt;artist; } public function getTracks() : array { return $this-&gt;tracks; } } An example class representing a track of an album. class Track { private ?string $title; private ?string $duration; public function __construct( ?string $title = null, ?string $duration = null ) { $this-&gt;title = $title; $this-&gt;duration = $duration; } public function getTitle() : ?string { return $this-&gt;title; } public function getDuration() : ?string { return $this-&gt;duration; } }","title":"Example"},{"location":"v4/strategies/datetime-immutable-formatter-strategy/","text":"DateTimeImmutableFormatter Available since version 3.1.0 DateTimeImmutableFormatterStrategy provides bidirectional conversion between strings and DateTimeImmutable instances . The strategy uses DateTimeFormatterStrategy for conversion where the input and output formats can be set. Basic Usage The following code example shows standalone usage without adding the strategy to a hydrator. Create and configure strategy Create the strategy and set the input and output formats via the DateTimeFormatterStrategy . $strategy = new Laminas\\Hydrator\\Strategy\\DateTimeImmutableFormatterStrategy( new Laminas\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d') ); Hydrate data $hydrated = $strategy-&gt;hydrate('2020-07-01'); var_dump($hydrated instanceof DateTimeImmutable); // true Extract data $extracted = $strategy-&gt;extract( DateTimeImmutable::createFromFormat('Y-m-d', '2020-07-01') ); echo $extracted // '2020-07-01' Example The following example demonstrates hydration for a class with a property. An example class which represents a music album with a release date: class Album { private ?DateTimeImmutable $releaseDate; public function __construct(?DateTimeImmutable $releaseDate = null) { $this-&gt;releaseDate = $releaseDate; } public function getReleaseDate() : ?DateTimeImmutable { return $this-&gt;releaseDate; } } Create hydrator and add strategy Create a hydrator and add DateTimeImmutableFormatterStrategy as strategy: $hydrator = new Laminas\\Hydrator\\ReflectionHydrator(); $hydrator-&gt;addStrategy( 'releaseDate', new Laminas\\Hydrator\\Strategy\\DateTimeImmutableFormatterStrategy( new Laminas\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d') ) ); Hydrate data Create an instance of the example class and hydrate data: $album = new Album(); $hydrator-&gt;hydrate(['releaseDate' =&gt; '2020-07-01'], $album); var_dump($album-&gt;getReleaseDate() instanceof DateTimeImmutable); // true Extract data $extracted = $hydrator-&gt;extract($album); echo $extracted; // '2020-07-01'","title":"DateTimeImmutableFormatter"},{"location":"v4/strategies/datetime-immutable-formatter-strategy/#datetimeimmutableformatter","text":"Available since version 3.1.0 DateTimeImmutableFormatterStrategy provides bidirectional conversion between strings and DateTimeImmutable instances . The strategy uses DateTimeFormatterStrategy for conversion where the input and output formats can be set.","title":"DateTimeImmutableFormatter"},{"location":"v4/strategies/datetime-immutable-formatter-strategy/#basic-usage","text":"The following code example shows standalone usage without adding the strategy to a hydrator.","title":"Basic Usage"},{"location":"v4/strategies/datetime-immutable-formatter-strategy/#example","text":"The following example demonstrates hydration for a class with a property. An example class which represents a music album with a release date: class Album { private ?DateTimeImmutable $releaseDate; public function __construct(?DateTimeImmutable $releaseDate = null) { $this-&gt;releaseDate = $releaseDate; } public function getReleaseDate() : ?DateTimeImmutable { return $this-&gt;releaseDate; } }","title":"Example"},{"location":"v4/strategies/hydrator/","text":"Hydrator Available since version 3.1.0 The HydratorStrategy can be used to hydrate an object and its child objects with data from a nested array and vice versa . Basic usage The following code example shows standalone usage without adding the strategy to a hydrator. Create and configure strategy Create the strategy and set a hydrator and a classname for the handled object. $strategy = new Laminas\\Hydrator\\Strategy\\HydratorStrategy( new Laminas\\Hydrator\\ObjectPropertyHydrator(), stdClass::class ); Hydrate data $hydrated = $strategy-&gt;hydrate([ 'firstName' =&gt; 'David', 'lastName' =&gt; 'Bowie', ]); echo $hydrated-&gt;firstName; // 'David' echo $hydrated-&gt;lastName; // 'Bowie' Extract data $class = new stdClass(); $class-&gt;firstName = 'David'; $class-&gt;lastName = 'Bowie'; $extracted = $strategy-&gt;extract($class); var_dump($extracted); // ['firstName' =&gt; 'David', 'lastName' =&gt; 'Bowie'] Example The following example shows the hydration for a class with a property that consumes another class. An example class which represents a music album. class Album { private ?int $id = null; private ?string $title = null; private ?Artist $artist = null; public function __construct( ?int $id = null, ?string $title = null, ?Artist $artist = null ) { $this-&gt;id = $id; $this-&gt;title = $title; $this-&gt;artist = $artist; } public function getId() : ?int { return $this-&gt;id; } public function getTitle() : ?string { return $this-&gt;title; } public function getArtist() : ?Artist { return $this-&gt;artist; } } An example class representing the artist of an album. class Artist { private ?string $firstName; private ?string $lastName; public function __construct( ?string $firstName = null, ?string $lastName = null ) { $this-&gt;firstName = $firstName; $this-&gt;lastName = $lastName; } public function getFirstName() : ?string { return $this-&gt;firstName; } public function getLastName() : ?string { return $this-&gt;lastName; } } Create hydrator and add strategy Create a hydrator and add HydratorStrategy as a strategy, with a hydrator and a classname for the handled object. $hydrator = new Laminas\\Hydrator\\ReflectionHydrator(); $hydrator-&gt;addStrategy( 'artist', new Laminas\\Hydrator\\Strategy\\HydratorStrategy( new Laminas\\Hydrator\\ReflectionHydrator(), Artist::class ) ); Hydrate data Create an instance of the example Album class and hydrate data. $album = new Album(); $hydrator-&gt;hydrate( [ 'id' =&gt; 100, 'title' =&gt; 'The Next Day (Deluxe Version)', 'artist' =&gt; [ 'firstName' =&gt; 'David', 'lastName' =&gt; 'Bowie', ], ], $album ); echo $album-&gt;getTitle(); // 'The Next Day (Deluxe Version)' echo $album-&gt;getArtist()-&gt;getFirstName(); // 'David' echo $album-&gt;getArtist()-&gt;getLastName(); // 'Bowie' Extract data var_dump($hydrator-&gt;extract($album)); /* array(3) { 'id' =&gt; int(100) 'title' =&gt; string(29) \"The Next Day (Deluxe Version)\" 'artist' =&gt; array(2) { 'firstName' =&gt; string(5) \"David\" 'lastName' =&gt; string(5) \"Bowie\" } } */","title":"Hydrator"},{"location":"v4/strategies/hydrator/#hydrator","text":"Available since version 3.1.0 The HydratorStrategy can be used to hydrate an object and its child objects with data from a nested array and vice versa .","title":"Hydrator"},{"location":"v4/strategies/hydrator/#basic-usage","text":"The following code example shows standalone usage without adding the strategy to a hydrator.","title":"Basic usage"},{"location":"v4/strategies/hydrator/#example","text":"The following example shows the hydration for a class with a property that consumes another class. An example class which represents a music album. class Album { private ?int $id = null; private ?string $title = null; private ?Artist $artist = null; public function __construct( ?int $id = null, ?string $title = null, ?Artist $artist = null ) { $this-&gt;id = $id; $this-&gt;title = $title; $this-&gt;artist = $artist; } public function getId() : ?int { return $this-&gt;id; } public function getTitle() : ?string { return $this-&gt;title; } public function getArtist() : ?Artist { return $this-&gt;artist; } } An example class representing the artist of an album. class Artist { private ?string $firstName; private ?string $lastName; public function __construct( ?string $firstName = null, ?string $lastName = null ) { $this-&gt;firstName = $firstName; $this-&gt;lastName = $lastName; } public function getFirstName() : ?string { return $this-&gt;firstName; } public function getLastName() : ?string { return $this-&gt;lastName; } }","title":"Example"},{"location":"v4/strategies/serializable/","text":"Serializable The SerializableStrategy can be used for serializing and deserializing PHP types to and from different representations . The strategy uses laminas-serializer for serializing and deserializing of data. Basic usage The following code example shows standalone usage without adding the strategy to a hydrator. Create and configure strategy Create the strategy and set a serializer adapter. $strategy = new Laminas\\Hydrator\\Strategy\\SerializableStrategy( new Laminas\\Serializer\\Adapter\\Json() ); For available serializer adapters see the documentation of laminas-serializer . Hydrate data $json = '[{\"title\":\"Modern Love\",\"duration\":\"4:46\"},{\"title\":\"China Girl\",\"duration\":\"5:32\"}]'; $hydrated = $strategy-&gt;hydrate($json); echo $hydrated[1]['title']; // 'China Girl' echo $hydrated[1]['duration']; // '5:32' Extract data $data = [ [ 'title' =&gt; 'Modern Love', 'duration' =&gt; '4:46', ], [ 'title' =&gt; 'China Girl', 'duration' =&gt; '5:32', ], // … ]; $extracted = $strategy-&gt;extract($data); echo $extracted; // '[{\"title\":\"Modern Love\",\"duration\":\"4:46\"},{\"title\":\"China Girl\",\"duration\":\"5:32\"}]' Example The following example shows the hydration for a class with a property where the data is provided by a JSON string. An example class which represents a music album with tracks. class Album { private ?string $title; private ?string $artist; private array $tracks; public function __construct( ?string $title = null, ?string $artist = null, array $tracks = [] ) { $this-&gt;title = $title; $this-&gt;artist = $artist; $this-&gt;tracks = $tracks; } public function getTitle() : ?string { return $this-&gt;title; } public function getArtist() : ?string { return $this-&gt;artist; } public function getTracks() : array { return $this-&gt;tracks; } } Create hydrator and add strategy Create a hydrator and add SerializableStrategy as a strategy, with a serializer adapter which converts the JSON string to array and vice versa. $hydrator = new Laminas\\Hydrator\\ReflectionHydrator(); $hydrator-&gt;addStrategy( 'tracks', new Laminas\\Hydrator\\Strategy\\SerializableStrategy( new Laminas\\Serializer\\Adapter\\Json() ) ); Hydrate data Create an instance of the example Album class and hydrate data. $album = new Album(); $hydrator-&gt;hydrate( [ 'artist' =&gt; 'David Bowie', 'title' =&gt; 'Let\\'s Dance', 'tracks' =&gt; '[{\"title\":\"Modern Love\",\"duration\":\"4:46\"},{\"title\":\"China Girl\",\"duration\":\"5:32\"}]', ], $album ); echo $album-&gt;getTitle(); // \"Let's Dance\" echo $album-&gt;getArtist(); // 'David Bowie' echo $album-&gt;getTracks()[1]['title']; // 'China Girl' echo $album-&gt;getTracks()[1]['duration']; // '5:32' Extract data var_dump($hydrator-&gt;extract($album)); /* array(3) { 'title' =&gt; string(11) \"Let's Dance\" 'artist' =&gt; string(11) \"David Bowie\" 'tracks' =&gt; string(84) \"[{\"title\":\"Modern Love\",\"duration\":\"4:46\"},{\"title\":\"China Girl\",\"duration\":\"5:32\"}]\" } */","title":"Serializable"},{"location":"v4/strategies/serializable/#serializable","text":"The SerializableStrategy can be used for serializing and deserializing PHP types to and from different representations . The strategy uses laminas-serializer for serializing and deserializing of data.","title":"Serializable"},{"location":"v4/strategies/serializable/#basic-usage","text":"The following code example shows standalone usage without adding the strategy to a hydrator.","title":"Basic usage"},{"location":"v4/strategies/serializable/#example","text":"The following example shows the hydration for a class with a property where the data is provided by a JSON string. An example class which represents a music album with tracks. class Album { private ?string $title; private ?string $artist; private array $tracks; public function __construct( ?string $title = null, ?string $artist = null, array $tracks = [] ) { $this-&gt;title = $title; $this-&gt;artist = $artist; $this-&gt;tracks = $tracks; } public function getTitle() : ?string { return $this-&gt;title; } public function getArtist() : ?string { return $this-&gt;artist; } public function getTracks() : array { return $this-&gt;tracks; } }","title":"Example"}]}